<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[一次弄懂Event Loop]]></title>
    <url>%2FJavaScript%2F%E4%B8%80%E6%AC%A1%E5%BC%84%E6%87%82Event%20Loop%2F</url>
    <content type="text"><![CDATA[最近浏览了一些前端的面试题，发现很多题目里都有问到 Event Loop。正好我收集整理了部分相关的信息，于是也来说说我理解的 Event Loop。 什么是Event Loop?JS主线程不断的循环往复的任务列表中读取任务并且执行任务，其中运行机制被称为事件循环（Event Loop）。Event Loop是一个执行模型，在不同的地方有不同的实现。浏览器和NodeJS基于不同的技术实现了各自的Event Loop。 浏览器的Event Loop是在html5的规范中明确定义。 NodeJS的Event Loop是基于libuv实现的。可以参考Node的官方文档以及libuv的官方文档。 libuv已经对Event Loop做出了实现，而HTML5规范中只是定义了浏览器中Event Loop的模型，具体的实现留给了浏览器厂商。 单线程的JavaScript我们都知道JavaScript是一门单线程的编程语言,也就是说程序的执行顺序是从上到下依次执行的并且同一时间段内只能有一段代码被执行。这是由于JavaScript在设计之初的定位是用来处理用户交互以及操作 DOM,如果 JavaScript 也设计成多线程,势必会带来很复杂的同步问题。 假设JavaScript有两个线程,一个线程需要删除某个DOM节点,另一个则要在该DOM节点上添加一些内容。这时候浏览器该以哪个线程为主，所以JavaScript是单线程的。 同步、异步 但是,单线程的JavaScript为了解决一些大量的一些异步请求,决定着它必须支持异步。虽然JavaScript是单线程的,可是浏览器内部并不是单线程的。 我们假设JavaScript只执行自己程序的代码,当遇到异步操作时把他丢给浏览器来处理,由浏览器的线程去执行,自己继续往下执行。那问题来了，异步之后的程序JavaScript还是需要处理的,那怎么办?没关系,让浏览器执行完异步之后,再把异步执行完的东西在给我们JavaScript,让JavaScript去执行不就好了。 同步 如果在函数返回结果的时候，调用者能够拿到预期的结果(就是函数计算的结果)，那么这个函数就是同步的. 1console.log('synchronous') // 执行后,立即返回了结果 如果是同步的函数,即使调用函数的过程中执行比较耗时,也会一直等待得到执行结果。1234567function synchronous() &#123; var time = +new Date(); while(+new Date() - time &gt; 2000) &#123;&#125; console.log('2秒过去了');&#125;synchronous();console.log('同步函数执行结束'); 执行结果122秒过去了同步函数执行结束 上面代码中,下面的console.log函数需要等待2s才可以执行, 这就是同步。从函数返回结果的时候,调用者就可以拿到预期的结果。 异步 如果在函数返回的时候,调用者还不能购得到预期结果,而是将来通过一定的手段得到（例如回调函数）,这就是异步。如果函数是异步的,发出调用之后马上返回,但是不会马上返回预期结果。调用者不必主动等待,当被调用者得到结果之后会通过回调函数主动通知调用者。 123456function asynchronous() &#123; setTimeout(function() &#123; console.log('2s过去了'); &#125;, 2000);&#125;console.log('异步函数执行结束'); 执行结果12异步函数执行结束2s过去了 上面asynchronous函数内部内容修改成使用setTimeout来延迟2s执行函数内部去的console.log。但实际函数执行的结果却和上面并不一样;是因为setTimeout函数是异步的,匿名函数为它的回调函数。 宏任务、微任务 JavaScript中有microtasks、macrotasks,它们是异步任务的一种类型,microtasks的优先级高于macrotasks。 宏任务（macrotasks, 又叫tasks） macrotasks的一些api script（整体代码） setTimeout setInterval setImmediate I/O UI渲染 微任务（microtasks） microtasks的一些api process.nextTick promise Object.observe MutationObserver async await、Promise、setTimeoutasync awaitasync await是ES7提出的一个异步回调最终解决方案的语法糖。1234async function asynchronous() &#123; return 'asynchronous';&#125;console.log(asynchronous()); // Promise。 上面代码打印出来的结果发现async 函数实际上还是一个Promise, 我们也可以对它使用thenable的形式获取数据。 12asynchronous().then(str =&gt; console.log(str)); // asynchronous// 打印出来的结果也证明asynchronous函数其实可以改写成Promise.resolve('asynchronous')。 我们在换一种形式观察async await 12345678910111213141516async function asynchronous() &#123; console.log('我在asynchronous之前'); const info = await asynchronous1(); console.log(info);&#125;function asynchronous1() &#123; return new Promise(resolve =&gt; &#123; console.log('await 开始'); setTimeout(() =&gt; &#123; resolve('asynchronous'); &#125;, 2000); &#125;)&#125;// 这里的打印结果为 我在asynchronous之前、await 开始、 asynchronous 这里我们可以看到info是需要在asynchronous1返回结果后才会继续执行下去,这和我们的Primise里面的thenable形式一样,这里我们其实可以转化一种写法会更加的清晰。 123456789function asynchronous2() &#123; console.log('我在asynchronous之前'); // await前面的代码 new Promise(resolve =&gt; &#123; console.log('await开始'); // await内部的代码。 永远在Promise内部这是同步执行的 setTimeout(() =&gt; &#123; resolve('asynchronous'); &#125;, 2000); &#125;).then(str =&gt; console.log(str)); // await下面的代码 通过thenable来执行&#125; await 的含义为等待,也就是 async 函数需要等待 await 后的函数执行完成并且有了返回结果（ Promise 对象）之后,才能继续执行下面的代码。await通过返回一个Promise对象来实现同步的效果。 promisePromise本身是同步的立即执行函数,当在 executor 中执行 resolve 或者 reject 的时候,此时是异步操作,会先执行 then/catch 等,当主栈完成后,才会去调用 resolve/reject 中存放的方法执行,打印 p 的时候是打印的返回结果,一个 Promise 实例。 12345678910111213console.log('script start')let promise1 = new Promise(function (resolve) &#123; console.log('promise1') resolve() console.log('promise1 end')&#125;).then(function () &#123; console.log('promise2')&#125;)setTimeout(function()&#123; console.log('settimeout')&#125;)console.log('script end')// 输出顺序: script start-&gt;promise1-&gt;promise1 end-&gt;script end-&gt;promise2-&gt;settimeout 当JS主线程执行到Promise对象时，promise1.then() 的回调就是一个 taskpromise1 是 resolved 或 rejected ：那这个 task 就会放入当前事件循环回合的 microtask queuepromise1 是 pending：这个 task 就会放入 事件循环的未来的某个(可能下一个)回合的 microtask queue 中setTimeout 的回调也是个 task ，它会被放入 macrotask queue 即使是 0ms 的情况 setTimeout123456console.log('script start') //1. 打印 script startsetTimeout(function()&#123; console.log('settimeout') // 4. 打印 settimeout&#125;) // 2. 调用 setTimeout 函数，并定义其完成后执行的回调函数console.log('script end') //3. 打印 script start// 输出顺序：script start-&gt;script end-&gt;settimeout Event Loop主线程循环的从异步队列中读取事件，这个过程其实就是 Event Loop。 Event Loop就是,执行一个宏任务的过程中遇到微任务时,将其放到微任务的事件队列里,当前宏任务执行完毕后,会查看微任务的事件队列,依次执行里面的微任务。如果还有宏任务的话,再重新开启宏任务。 1234567891011121314151617181920async function async1() &#123; console.log('async1 start') await async2() console.log('async1 end')&#125;async function async2() &#123; console.log('async2')&#125;console.log('script start')setTimeout(function () &#123; console.log('settimeout')&#125;)async1()new Promise(function (resolve) &#123; console.log('promise1') resolve()&#125;).then(function () &#123; console.log('promise2')&#125;)console.log('script end') 执行同步任务console.log打印出script start。 将setTimeout放到宏任务队列,此时宏任务队列为[‘settimeout’]。 执行async1 内部的第一个console.log 打印出async1 start。 await执行方法大概同等于Promise.resolve直接同步打印出async2。 将async1内部的await下面的console.log放到微任务列, 此时微任务队列为[‘async1end’]。 函数返回一个Promise,因为这是一个同步任务,打印出promise1。 promise.then返回一个微任务,此时微任务队列为 [‘async1end’,’promise2’]。 执行同步任务打印出script end。 因为微任务执行优先,打印出async2, promise2。 最后打印async2。 结果 script start -&gt; async1 start -&gt; async2 -&gt; promise1 -&gt; async1 end -&gt; promise2 -&gt; settimeout 注意1 每一个 event loop 都有一个 microtask queue2 每个 event loop 会有一个或多个macrotask queue ( 也可以称为task queue )3 一个任务 task 可以放入 macrotask queue 也可以放入 microtask queue中4 每一次event loop，会首先执行 microtask queue， 执行完成后，会提取 macrotask queue 的一个任务加入 microtask queue， 接着继续执行microtask queue，依次执行下去直至所有任务执行结束。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>异步</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你想知道的清除浮动的方法都在这了]]></title>
    <url>%2FCss%2F%E4%BD%A0%E6%83%B3%E7%9F%A5%E9%81%93%E7%9A%84%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8%E7%9A%84%E6%96%B9%E6%B3%95%E9%83%BD%E5%9C%A8%E8%BF%99%E4%BA%86%2F</url>
    <content type="text"><![CDATA[浮动的产生 浮动float的产生原本是实现简单的布局，包括在一列文本中浮动的图像，文字环绕在它的左边或右边。你可能在报纸版面上看到过;包括有时候我们会希望几个div标签可以并排的出现在一行。 1234567891011121314151617181920&lt;style&gt;.wrapper1 &#123; width: 100%; background-color: lightgreen;&#125;.wrapper2 &#123; width: 100%; height: 100px; background-color: red;&#125;.box1 &#123; width: 100px; height: 100px; background-color: pink;&#125;&lt;/style&gt;&lt;div class="wrapper1"&gt; &lt;div class="box1"&gt;&lt;/div&gt;&lt;div class="wrapper2"&gt;&lt;/div&gt; 我们最简单的在上面的box1里面加上一条浮动的样式。123.box1 &#123; float: left;&#125; 即被box1元素设置float: left属性之后,box1这个元素变成了浮动元素。 浮动也会给我们平常的开发带来一些意想不到的副作用比如父元素高度坍塌,下面记录一下实际工作过程中清除浮动的几种方法其它们的优缺点。 父级定义height一般使用这种方法直接去设置父元素高度需要确定内容高度才能设置,修改上面的wrapper1的样式。12345.wrapper1 &#123; width: 100%; height: 100px; background-color: lightgreen;&#125; 优点: 简单、代码少、容易掌握。 缺点: 只适用于高度确定的布局,必须给出精确的高度;若高度和父级div不一致时,会产生问题。 父元素设置overflow:hidden对父元素设置overflow:hidden属性实际上是通过BFC机制包含浮动元素来清楚内部浮动(清除浮动的原理是两个div都位于同一个 BFC 区域之中) 12345.wrapper1 &#123; width: 100%; background-color: lightgreen; overflow: hidden;&#125; 优点: 简单、无需添加新的标签 缺点: 不能和position配合使用,因为超出的尺寸的部分会被隐藏。 父元素同时设置浮动对父元素同时设置float: left使其也形成一个BFC区域来清楚内部的浮动 12345.wrapper1 &#123; width: 100%; background-color: lightgreen; float: left;&#125; 但这时由于wrapper1变成浮动元素后,下面的wrapper2元素会由于wrapper1脱离文档流提到上面来,为了阻止这个问题我们需要将wrapper2也浮动起来 123456.wrapper2 &#123; width: 100%; height: 100px; background-color: red; float: left;&#125; 优点: 没有什么优点,不推荐使用。 缺点: 会产生新的浮动问题。 clear: bothclear clear 属性规定元素的哪一侧不允许其他浮动元素。 clear 属性定义了元素的哪边上不允许出现浮动元素。在 CSS1 和 CSS2 中，这是通过自动为清除元素（即设置了 clear 属性的元素）增加上外边距实现的。在 CSS2.1 中，会在元素上外边距之上增加清除空间，而外边距本身并不改变。不论哪一种改变，最终结果都一样，如果声明为左边或右边清除，会使元素的上外边框边界刚好在该边上浮动元素的下外边距边界之下。 clear属性的值 left: 在左侧不允许浮动元素。 right: 在右侧不允许浮动元素。 both: 在左右两侧均不允许浮动元素。 none: 默认值。允许浮动元素出现在两侧。 inherit: 规定应该从父元素继承 clear 属性的值。 clear使用12345678910&lt;style&gt;.clear &#123; clear: both;&#125;&lt;/style&gt;&lt;div class="wrapper1"&gt; &lt;div class="box1"&gt; &lt;div class="clear"&gt;&lt;/div&gt;&lt;div class="wrapper2"&gt;&lt;/div&gt; 这里我们在wrapper1的结尾处添加一个class为clear的div元素。该元素样式为clear: both(这里也可以设置为clear: left)。我们前面知道clear是用来清除浮动的,所以我们使用这个方法来禁止该元素两边的浮动关系。 优点: 方便使用。 缺点: 冗余元素,会多加HTML空标签。 after伪元素这个方法是在上面那个方法上优化的一种方法,前面我们说到clear: both可以清除浮动,但是由于我们多添加了一个div元素导致了代码上多了不必要的元素并且不符合语义化,所以这里我们换一种方式;在父元素的伪元素内使用clear: both属性。 12345678910111213141516&lt;style&gt;.clearfix: &#123; zoom: 1; // 用于兼容IE,IE下haslayout，使元素根据自身内容计算宽高&#125;.clearfix:after &#123; content: ""; display: block; height: 0; visibility:hidden; clear: both;&#125;&lt;/style&gt;&lt;div class="wrapper1 clearfix"&gt; &lt;div class="box1"&gt;&lt;/div&gt;&lt;div class="wrapper2"&gt;&lt;/div&gt; 优点: 方便使用。 缺点: 总结清除浮动的两大基本方法: clear:both; 父元素BFC(ie8+)或haslayout(ie6/ie7)。]]></content>
      <categories>
        <category>Css</category>
      </categories>
      <tags>
        <tag>Css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue组件内通信方式整理]]></title>
    <url>%2FVue%2FVue%E7%BB%84%E4%BB%B6%E5%86%85%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[props和$emit父组件向子组件传递数据是通过props来传递的,子组件传递数据给父组件是通过$emit触发事件来做到的,父组件中使用v-on（@）的方式来实现。 父组件向子组件传值父组件通过v-bind指令向子组件传递一个name为todoList的一个值。1234567891011121314151617181920212223242526// Parent.vue&lt;template&gt; &lt;div&gt; &lt;template v-if="todoList &amp;&amp; todoList.length &gt; 0"&gt; &lt;child v-for="(todo, index) in todoList" :todo="todo" :key="index"&gt;&lt;/child&gt; &lt;/template&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import Child from '@/components/Child'; // 这里的@是由于vue-cli内webpack配置alias别名用以替代src '@':resolve('src')export default &#123; components: &#123; Child, &#125;, data() &#123; return &#123; todoList: ['吃饭', '睡觉', '打豆豆'], &#125;; &#125;,&#125;;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; 子组件通过props来获取父组件传递过来的值123456789101112131415161718192021// Child.vue&lt;template&gt; &lt;div&gt; &lt;span&gt;&#123;&#123; todo &#125;&#125;&lt;/span&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; props: &#123; todo: &#123; default: '', type: [String, Number], &#125;, &#125;,&#125;;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; 父组件通过props向下给子组件传递值,props只能出父组件传递到子组件并且是无法向上传递数据也就是我们常说的单项数据流,props是只能读取的属性,不可以修改，所有修改都会失效;如果一定要将修改props传递下来的数据的话,我们只能把数据存储在子组件的data里面。 12345678910111213export default &#123; props: &#123; todo: &#123; default: '', type: [String, Number], &#125;, &#125;, data () &#123; return &#123; todoItem: this.todo, &#125;; &#125;,&#125;; 子组件向父组件传值我们在子组件内部加上一个删除按钮，其功能是点击删除按钮删除对应的内容信息。这里就需要使用到我们的子组件向父组件传值,子组件向父组件传值需要使用到我们的$emit方法。 12345678910111213// 修改Parent.vue...&lt;child @delete="deleteTodo" v-for="(todo, index) in todoList" :todo="todo" :key="todo" :index="index"&gt;&lt;/child&gt; ...&lt;script&gt;export default &#123; methods: &#123; deleteTodo(index) &#123; this.todoList.splice(index, 1); &#125; &#125;,&#125;;&lt;/script&gt; 123456789101112131415161718192021222324// 修改Child.vue...&lt;div&gt; &lt;span&gt;&#123;&#123; todo &#125;&#125;&lt;/span&gt; &lt;span @click="onDeleteTodo"&gt;删除&lt;/span&gt;&lt;/div&gt;...&lt;script&gt;export default &#123; props: &#123; ..., index: &#123; default: 0, type: Number, &#125;, &#125;, methods: &#123; onDeleteTodo() &#123; this.$emit('delete', this.index); &#125;, &#125;,&#125;;&lt;/script&gt; 这里父组件的key值不能再为index。由于key值是一个唯一的值,我们在操作删除操作时数组的索引会重新计算,如果使用index值为key值的话会出现一些视图显示错误的问题;这里就不多阐述了,有兴趣的朋友可以自行研究一下。 子组件通过$emit向父组件发送消息并把需要发送的数据作为参数传递给方法内。这里我们子组件一个按钮上绑定一个删除事件onDeleteTodo,方法内部触发父组件上绑定的delete事件并传递参数为当前点击按钮的index,父组件绑定delete事件的函数deleteTodo会将todoList上对应的index的那项删除掉就完成了我们的子组件向父组件传值的过程。 $parent和$children($root)子实例可以通过this.$parent访问父实例,子实例被推入父实例的$children数组中。 官网上推动我们节制地使用 $parent 和 $children - 它们的主要目的是作为访问组件的应急方法。更推荐用 props 和 events 实现父子组件通信 12345678910111213141516171819202122232425// 父组件&lt;template&gt; &lt;div&gt; &lt;child&gt;&lt;/child&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import Child from '@/components/Child';export default &#123; components: &#123; Child, &#125;, data() &#123; return &#123; msg1: '我是根节点root', msg2: '我是从父节点传递过来的信息', &#125;; &#125;, mounted() &#123; console.log(this.$root.msg1); // 假设parent是根节点的话, 这里打印 我是根节点root console.log(thihs.$children[0].msg3); // 我是从子节点传递过来的信息 &#125;,&#125;;&lt;/script&gt; 1234567891011// 子组件export default &#123; data () &#123; return &#123; msg3: '我是从子节点传递过来的信息', &#125;; &#125;, mounted() &#123; console.log(this.$parent.msg2); // 我是从父节点传递过来的信息 这里等同于this.$root.msg2 &#125;,&#125; refs和refrefs和ref的用法和上面的$children非常的相似,我们的子组件使用上个通信方式定义的文件,修改下我们的父组件 12345678910111213141516171819// 父组件// 父组件&lt;template&gt; &lt;div&gt; &lt;child ref="children"&gt;&lt;/child&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import Child from '@/components/Child';export default &#123; components: &#123; Child, &#125;, mounted() &#123; console.log(thihs.$refs.children.msg3); // 我是从子节点传递过来的信息 &#125;,&#125;;&lt;/script&gt; provide和injectprovide和inject需要放在一起使用,允许一个祖先组件向其所有子孙后代注入一个依赖,不论组件层次有多少深,在其上下游关系中始终生效。 provider和inject绑定并不是响应式的,这是刻意为之的。然而，如果你传入了一个可监听的对象，那么其对象的属性还是可响应的。 假设父组件设置provide如下12345678// Parent.vue 父组件export default &#123; provide() &#123; return &#123; name: 'provider和inject', &#125;; &#125;,&#125;; 后代组件1234567// GrandChild.vue 后代组件export default &#123; inject: ['name'], mounted() &#123; console.log(this.name); // provider和inject &#125;,&#125;; 这里我们在父组件上设置一个provide,其中属性name的值为’provider和inject’,传递给后代组件通过inject获取,在后代组件内获取后,就正常的可以通过this.name属性来访问。 $attrs和$listeners$attrs: 包含了父作用域中不作为prop被识别（且获取）的特性绑定（class和style除外）。当一个组件没有声明任何prop时，这里会包含所有父作用域的绑定（class和style除外）,并且可以通过v-bind=”$attrs”传入内部组件 $listeners: 包含了父作用域中的（不含.native修饰器的）v-on事件监听器。它可以通过v-on=”$listeners”传入内部组件 Vue2.4提供了$attrs , $listeners 来传递数据与事件，跨级组件之间的通讯变得更简单。其中$attr负责整合组件的属性而$listeners负责整合组件的方法,并且两者都以对象形式来保存数据。 假设一个跨级通信情况 A -&gt; B -&gt; C。正常情况下我们都会使用props逐级传递下去,但是使用$attrs以及$listeners后逐级向下传递数据后不在需要以前那样繁琐的重复定义props。需要数据的组件只需要定位一个props,剩余的数据会继续向下进行传递。 父组件A 父组件A下存在一个子组件B,并传递两条数据bMsg,cMsg以及绑定两个方法bData和cData。 12345678910111213141516171819202122232425262728&lt;template&gt; &lt;div&gt; &lt;p&gt;这是一个父组件&lt;/p&gt; &lt;B :b-msg="bMsg" :c-msg="cMsg" @bData="getChildData" @cData="getGrandChildData"&gt;&lt;/B&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import B from '@/components/B';export default &#123; components: &#123; B, &#125;, data() &#123; return &#123; bMsg: '这是一个子组件', cMsg: '这是一个后代组件', &#125;; &#125;, methods: &#123; getChildData(data) &#123; console.log(`子组件数据: $&#123;data&#125;`); &#125;, getGrandChildData(data) &#123; console.log(`后代组件数据: $&#123;data&#125;`); &#125;, &#125;,&#125;;&lt;/script&gt; 子组件B 子组件接受父组件传递的数据bMsg,并调用bData方法;将$attrs绑定到后代组件C上,由于$attrs含了父作用域中不作为prop被识别的特性绑定,所以这时$attr为{ c-msg: ‘这是一个后代组件’ }, $listeners: { bData: f(), cData: f()}。 12345678910111213141516171819202122232425&lt;template&gt; &lt;div&gt; &lt;p&gt; &lt;span&gt;&#123;&#123;bMsg&#125;&#125;&lt;/span&gt;&lt;span @click="postData"&gt;点我传递数据&lt;/span&gt; &lt;/p&gt; &lt;C v-bind="$attrs" v-on="$listeners"&gt;&lt;/C&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import C from '@/components/C';export default &#123; components: &#123; C, &#125;, props: ['bMsg'], methods: &#123; postData() &#123; this.$emit('bData', '子组件数据'); // 调用A v-on:bData &#125;, &#125;, created() &#123; console.log(this.$attrs, this.$listeners); // $attr: &#123; c-msg: '这是一个后代组件' &#125; $listeners: &#123; bData: f(), cData: f()&#125; &#125;,&#125;;&lt;/script&gt; 后代组件C 后代组件C接受来自子组件B传递下来的数据; 123456789101112131415&lt;template&gt; &lt;p&gt; &lt;span&gt;&#123;&#123;cMsg&#125;&#125;&lt;/span&gt;&lt;span @click="postData"&gt;点我传递数据&lt;/span&gt; &lt;/p&gt;&lt;/template&gt;&lt;script&gt;export default &#123; props: ['cMsg'], methods: &#123; postData() &#123; this.$emit('cData', '后代组件数据'); // 调用A v-on:cData &#125;, &#125;,&#125;&lt;/script&gt; eventBusevevntBus是消息传递的一种方式,又被称为事件总线。 创建一个实例Bus首先我们创建一个eventBus 并将其导出。 123// Bus.jsimport Vue from 'vue';export default new Vue(); 创建两个兄弟组件A以及B组件以及一个父组件Parent123456789101112131415161718// Parent.vue&lt;template&gt; &lt;div&gt; &lt;a&gt;&lt;/a&gt; &lt;b&gt;&lt;/b&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import A from '@/components/A';import B from '@/components/B';export default &#123; components: &#123; A, B, &#125;,&#125;&lt;/script&gt; 组件B发送事件123456789101112131415// B.vue&lt;template&gt; &lt;div @click="createRandom"&gt;点击生成随机数&lt;/div&gt;&lt;/template&gt;&lt;script&gt;import Bus from '@/bus/Bus';export default &#123; methods: &#123; createRandom() &#123; const number = Math.floor(Math.random() * 10); Bus.$emit('passNumber', number) &#125;, &#125;, &#125;;&lt;/script&gt; 组件A接收事件12345678910111213141516171819202122// A.vue&lt;template&gt; &lt;div&gt;&#123;&#123; number &#125;&#125;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;import Bus from '@/bus/Bus';export default &#123; data() &#123; return &#123; number: null, &#125;; &#125;, created() &#123; Bus.$on('passNumber', (number) =&gt; &#123; this.number = number; &#125;); &#125;, beforeDestroy() &#123; Bus.$off('passNumber'); &#125;,&#125;&lt;/script&gt; 组件B中有一个按钮并绑定点击事件点击后向组件A传递一个随机数并在组件A上显示。 eventBus是一种创建一个新的vue实例做观察者的方式,订阅和发布事件;vm实例上存在$on、$once、$off、$emit几个方法。 localStorage和sessionStorage这种通信比较简单,缺点是数据和状态比较混乱,不太容易维护。 通过window.localStorage.getItem(key)获取数据通过window.localStorage.setItem(key, value)存储数据 localStorage / sessionStorage可以结合vuex, 实现数据的持久保存,同时使用vuex解决数据和状态混乱问题。 vuexVuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。 每一个 Vuex 应用的核心就是 store（仓库）。“store”基本上就是一个容器，它包含着你的应用中大部分的状态 (state)。Vuex 和单纯的全局对象有以下两点不同： Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。 你不能直接改变 store 中的状态。改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样使得我们可以方便地跟踪每一个状态的变化，从而让我们能够实现一些工具帮助我们更好地了解我们的应用。 Vuex的各个模块 state：用于数据的存储，是store中的唯一数据源 getters：如vue中的计算属性一样，基于state数据的二次包装，常用于数据的筛选和多个数据的相关性计算 mutations：类似函数，改变state数据的唯一途径，且不能用于处理异步事件 actions：类似于mutation，用于提交mutation来改变状态，而不直接变更状态，可以包含任意异步操作 modules：类似于命名空间，用于项目中将各个模块的状态分开定义和操作，便于维护 动手写一个简单的Vuex命令行执行命令安装vuex1npm i -S vuex 在src目录下创建一个store文件夹,继续在store文件夹下创建一个index.js文件1234567891011121314151617181920212223242526import Vue from 'vue';import Vuex from 'Vuex';const INCREASE = 'INCREASE';const DECREASE = 'DECREASE';Vue.use(Vuex);export default new Vuex.Store(&#123; state: &#123; count: 0, &#125;, mutations: &#123; [INCREASE](state) &#123; state.count++; &#125;, [DECREASE](state) &#123; state.count--; &#125;, &#125;, actions: &#123; increaseCount(&#123; commit &#125;) &#123; commit(INCREASE); &#125;, decreaseCount(&#123; commit &#125;) &#123; commit(DECREASE); &#125;, &#125;,&#125;); main.js添加以下代码12345678import Store from '@/store';new Vue(&#123; el: '#app', router, components: &#123; App &#125;, template: '&lt;App/&gt;', store,&#125;) 创建父组件A1234567891011121314151617181920212223&lt;template&gt; &lt;div&gt; &lt;p&gt;这是一个父组件&lt;/p&gt; &lt;B&gt;&lt;/B&gt; &lt;span @click="increaseCount"&gt;增加&lt;/span&gt; &lt;span @click="decreaseCount"&gt;减少&lt;/span&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123; mapActions &#125; from 'vuex';import B from '@/components/B';export default &#123; components: &#123; B, &#125;, methods: &#123; ...mapActions([ 'increaseCount', 'decreaseCount', ]), &#125;,&#125;;&lt;/script&gt; 创建子组件B 123456789101112131415&lt;template&gt; &lt;div&gt; &lt;p&gt;&#123;&#123;count&#125;&#125;&lt;/p&gt; &lt;/div&gt;&lt;/template&gt; &lt;script&gt;import &#123; mapState &#125; from 'vuex';export default &#123; computed: &#123; ...mapState([ 'count' ]), &#125;,&#125;;&lt;/script&gt; 上面代码简单实现了使用Vuex在父子组件之内传递数据,点击父组件增加减少按钮,子组件内显示count就会同样重新计算。有更多的想要了解Vuex,可以参考一下Vuex官方文档。]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[跨域的正确打开方式]]></title>
    <url>%2F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F%E8%B7%A8%E5%9F%9F%E7%9A%84%E6%AD%A3%E7%A1%AE%E6%89%93%E5%BC%80%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[跨域是前端开发日常工作中经常会面对的一个问题。日常工作中我们都会使用像webpack-dev-server构建我们的开发环境的接口代理、亦或是使用Charles等接口代理工具。上线后可以通过运维同学配合nginx或是cors等方案来解决。 什么是跨域？ 在JavaScript中，有一个很重要的安全性限制，被称为“Same-Origin Policy”（同源策略）。这一策略对于JavaScript代码能够访问的页面内容做了很重要的限制，即JavaScript只能访问与包含它的文档在同一域下的内容。跨域是指浏览器不能执行其他网站的脚本。MDN上的解释(浏览器的同源策略限制了从同一个源加载的文档或脚本如何与另一个源的资料进行交互，这是一个用于隔离潜在恶意文件的重要机制)。简而言之就是浏览器对脚本实施的安全机制。 同源的定义有两个页面的协议、端口（如果有指定）和主机都相同，则两个页面具有相同的源，即为同源。若协议/端口/主机 有一项不同，则为说明两者非同源。 Url 调用 Url 结果 http://www.peanutyu.site/home http://www.peanutyu.site/api/* 调用成功,非跨域 http://www.peanutyu.site/home http://www.peanut.site/api/* 调用失败,主域名不同 http://www.peanutyu.site/home https://www.peanutyu.site/api/* 调用失败,协议不同 http://www.peanutyu.site/home http://blog.peanutyu.site/api/* 调用失败,子域名不同 http://www.peanutyu.site/home http://www.peanutyu.site:8080/api/* 调用失败,端口号不同 JSONP跨域（JSON with padding）在HTML标签里，一些标签比如script、img、iframe这些获取资源的标签是没有跨域限制的，JSONP就是我们去动态的创建一个Script标签再去请求一个带参网址来实现跨域通信。由于script标签加载资源的方式是GET请求,所以JSONP只能发送GET请求。 后台接口设计1234567891011121314const xxService = require('../../service/xxService');exports = module.exports = new class &#123; constructor() &#123;&#125; jsonp () &#123; let [cb, username ] = []; if (ctx.query) &#123; (&#123; cb, username &#125; = ctx.query); &#125; const data = await xxService.xxMethods(username); // cb参数是前后端约定的方法名字,后端返回一个直接执行的方法给前端,前端获取这个方法后立马执行，并且把返回的数据放在方法的参数里。 ctx.body = `$&#123;cb&#125;($&#123;JSON.stringify(data)&#125;)`; &#125;&#125; 前端方法实现原生的实现方式1234567891011const script = document.createElement('script');const body = document.body;script.src = 'http://127.0.0.1:3000/api/jsonp?cb=callbackJsonp&amp;username=peanut';body.appendChild(script);function callbackJsonp(res) &#123; const div = document.createElement('div'); div.innerText = JSON.stringify(res); body.appendChild(div); body.removeChild(script);&#125; Jquery的实现方式12345678910111213$.ajax(&#123; url: 'http://blog.peanutyu.site/api/*', type: 'GET', dateType: 'jsonp', // 设置请求方式为jsonp jsonpCallback: 'callbackJsonp', data: &#123; 'username': 'peanut', &#125;,&#125;);function callbackJsonp(res) &#123; console.log(res);&#125; iframe跨域document.domain + iframe 跨域这种跨域方式要求主域名相同。比如www.peanut.site、blog.peanut.site、 a.peanutyu.site这三者主域名都是peanutyu.site。主域名不同就不能使用这种跨域方式。 浏览器不同域的页面之间是不可以通过JS来进行交互操作的。但是不同的页面，是能够获取到彼此的window对象的。但是，我们只能获取到一个几乎无用的window对象。比如一个页面它的地址为http://www.peanutyu.site/a.html,在这一个页面里有一个iframe,它的src为http://peanutyu.site/b.html,这个页面和它内部的iframe是不同域的,所以我们是无法通过在页面中书写js代码来获取iframe中的东西的。我们只需要把http://www.peanutyu.site/a.html和http://peanutyu.site/b.html都设置成相同的域名即可。 但需要注意的是document.domain的设置是有限制的，我们只能把document.domain设置成自身或更高一层的父域，并且主域必须相同。blog.peanutyu.site中某个文档可以设置document.domain为blog.peanutyu.site或者peanutyu.site中的任何一个，但是不能设置为a.blog.peanutyu.site。因为这是当前域的子域，也不可设置为baidu.com,因为主域不同。 假设我们要在http://www.peanutyu.site/a.html的页面里访问http://peanutyu.site里面的数据 在http://www.peanutyu.site/a.html设置document.domain12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;A页面&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;iframe id="iframe" src="http://peanutyu.site/b.html" style="display:none;"&gt;&lt;/iframe&gt; &lt;script&gt; $(function () &#123; try &#123; document.domain = "peanutyu.site"; //这里将document.domain设置成一样 &#125; catch (e) &#123; &#125; $("#iframe").load(function () &#123; var iframe = $("#iframe").contentDocument.$; iframe.get("http://peanutyu.site/api", function (data) &#123; console.log(data); &#125;); &#125;); &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 在http://peanutyu.site/b.html也需要设置document.domain。123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;B页面&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; $(function () &#123; try &#123; document.domain = "peanutyu.site"; //这里将document.domain设置成一样 &#125; catch (e) &#123; &#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 这里需要注意，在A页面内需要等待加载完B页面之后才可以获取到B页面中的$对象。获取到$对象我们便可以直接发送ajax请求,不过这种跨域方式只可以在主域相同的时候使用。 window.name + iframe 跨域当iframe页面跳转到其他地址时,其window.name值保持不变并且可以支持存储非常长的name(2MB)。但是浏览器规定浏览器跨域iframe禁止互相调用或者传递值。但是调用iframe时window.name却不变,我们正好可以使用这个特性来互相传值,当然跨域下是不容许读取iframe的window.name的值。 因为规定如果index.html页面和该页面里的iframe的src如果不同源，就无法操作iframe内部的任何内容,所以也获取不到iframe的window.name属性了。不过既然要同源,我们可以准备一个和主页面http://www.peanut.com/a.html相同域下的代理空页面http://www.peanut.com/proxy.html来指定src。 假设我们有一个页面http://peanutyu.site/a.html需要从http://peanut.site/data.html内获取到数据 data页面代码1window.name = '我是data页面的数据'; a页面代码1234567891011121314151617const iframe = document.createElement('iframe');iframe.style.display = 'none';let state = 0;iframe.onload = function() &#123; if (state === 1) &#123; const data = iframe.contentWindow.name; iframe.contentWindow.document.write(''); iframe.contentWindow.close(); document.body.removeChild(iframe); &#125; else &#123; state = 1; iframe.contentWindow.location = 'http://peanutyu.site/proxy.html'; &#125;&#125;iframe.src = 'http://peanut.site/data.html';document.body.appendChild(iframe); 在iframe载入的过程中,迅速重置iframe的location等同于重新载入页面，便会重新调用iframe的onload方法这时我们的会走到条件为state === 1的内部，获取iframe的window.name的值，由于调用iframe时window.name不变,所以我们便取到了不同域内window.name的值。 跨域资源共享CORS简介CORS需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE浏览器不能低于IE10。整个CORS通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS通信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。因此，实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信。 两种请求浏览器将CORS请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）。只要同时满足以下两大条件，就属于简单请求。(1) 请求方法是下面三种方法之一: HEAD GET POST (2) HTTP的头信息不超出以下几种字段: Accept Accept-Language Content-Language Last-Event-ID Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain 凡是不同时满足上面两个条件，就属于非简单请求。浏览器对这两种请求的处理，是不一样的。 简单请求基本流程对于简单请求，浏览器直接发出CORS请求。具体来说，就是在头信息之中，增加一个Origin字段。下面是一个例子，浏览器发现这次跨源AJAX请求是简单请求，就自动在头信息之中，添加一个Origin字段。 123456GET /cors HTTP/1.1Origin: http://api.bob.comHost: api.alice.comAccept-Language: en-USConnection: keep-aliveUser-Agent: Mozilla/5.0... 上面的头信息中，Origin字段用来说明，本次请求来自哪个源（协议 + 域名 + 端口）。服务器根据这个值，决定是否同意这次请求。 如果Origin指定的源，不在许可范围内，服务器会返回一个正常的HTTP回应。浏览器发现，这个回应的头信息没有包含Access-Control-Allow-Origin字段（详见下文），就知道出错了，从而抛出一个错误，被XMLHttpRequest的onerror回调函数捕获。注意，这种错误无法通过状态码识别，因为HTTP回应的状态码有可能是200。 如果Origin指定的域名在许可范围内，服务器返回的响应，会多出几个头信息字段。 1234Access-Control-Allow-Origin: http://api.bob.comAccess-Control-Allow-Credentials: trueAccess-Control-Expose-Headers: FooBarContent-Type: text/html; charset=utf-8 上面的头信息之中，有三个与CORS请求相关的字段，都以Access-Control-开头。 Access-Control-Allow-Origin该字段是必须的。它的值要么是请求时Origin字段的值，要么是一个*，表示接受任意域名的请求。 Access-Control-Allow-Credentials该字段可选。它的值是一个布尔值，表示是否允许发送Cookie。默认情况下，Cookie不包括在CORS请求之中。设为true，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器。这个值也只能设为true，如果服务器不要浏览器发送Cookie，删除该字段即可。 Access-Control-Expose-Headers该字段可选。CORS请求时，XMLHttpRequest对象的getResponseHeader()方法只能拿到6个基本字段：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma。如果想拿到其他字段，就必须在Access-Control-Expose-Headers里面指定。上面的例子指定，getResponseHeader(‘FooBar’)可以返回FooBar字段的值。 withCredentials 属性上面说到，CORS请求默认不发送Cookie和HTTP认证信息。如果要把Cookie发到服务器，一方面要服务器同意，指定Access-Control-Allow-Credentials字段。1Access-Control-Allow-Credentials: true 另一方面，开发者必须在AJAX请求中打开withCredentials属性。12var xhr = new XMLHttpRequest();xhr.withCredentials = true; 否则，即使服务器同意发送Cookie，浏览器也不会发送。或者，服务器要求设置Cookie，浏览器也不会处理。但是，如果省略withCredentials设置，有的浏览器还是会一起发送Cookie。这时，可以显式关闭withCredentials。 1xhr.withCredentials = false; 需要注意的是，如果要发送Cookie，Access-Control-Allow-Origin就不能设为星号，必须指定明确的、与请求网页一致的域名。同时，Cookie依然遵循同源政策，只有用服务器域名设置的Cookie才会上传，其他域名的Cookie并不会上传，且（跨源）原网页代码中的document.cookie也无法读取服务器域名下的Cookie。 非简单请求预检请求非简单请求是那种对服务器有特殊要求的请求，比如请求方法是PUT或DELETE，或者Content-Type字段的类型是application/json。非简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为”预检”请求（preflight）。浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的XMLHttpRequest请求，否则就报错。下面是一段浏览器的JavaScript脚本。 12345var url = 'http://api.alice.com/cors';var xhr = new XMLHttpRequest();xhr.open('PUT', url, true);xhr.setRequestHeader('X-Custom-Header', 'value');xhr.send(); 上面代码中，HTTP请求的方法是PUT，并且发送一个自定义头信息X-Custom-Header。浏览器发现，这是一个非简单请求，就自动发出一个”预检”请求，要求服务器确认可以这样请求。下面是这个”预检”请求的HTTP头信息。 12345678OPTIONS /cors HTTP/1.1Origin: http://api.bob.comAccess-Control-Request-Method: PUTAccess-Control-Request-Headers: X-Custom-HeaderHost: api.alice.comAccept-Language: en-USConnection: keep-aliveUser-Agent: Mozilla/5.0... “预检”请求用的请求方法是OPTIONS，表示这个请求是用来询问的。头信息里面，关键字段是Origin，表示请求来自哪个源。除了Origin字段，”预检”请求的头信息包括两个特殊字段。 Access-Control-Request-Method该字段是必须的，用来列出浏览器的CORS请求会用到哪些HTTP方法，上例是PUT。 Access-Control-Request-Headers该字段是一个逗号分隔的字符串，指定浏览器CORS请求会额外发送的头信息字段，上例是X-Custom-Header。 预检请求的回应服务器收到”预检”请求以后，检查了Origin、Access-Control-Request-Method和Access-Control-Request-Headers字段以后，确认允许跨源请求，就可以做出回应。 123456789101112HTTP/1.1 200 OKDate: Mon, 01 Dec 2008 01:15:39 GMTServer: Apache/2.0.61 (Unix)Access-Control-Allow-Origin: http://api.bob.comAccess-Control-Allow-Methods: GET, POST, PUTAccess-Control-Allow-Headers: X-Custom-HeaderContent-Type: text/html; charset=utf-8Content-Encoding: gzipContent-Length: 0Keep-Alive: timeout=2, max=100Connection: Keep-AliveContent-Type: text/plain 上面的HTTP回应中，关键的是Access-Control-Allow-Origin字段，表示http://api.bob.com可以请求数据。该字段也可以设为星号，表示同意任意跨源请求。 1Access-Control-Allow-Origin: * 如果浏览器否定了”预检”请求，会返回一个正常的HTTP回应，但是没有任何CORS相关的头信息字段。这时，浏览器就会认定，服务器不同意预检请求，因此触发一个错误，被XMLHttpRequest对象的onerror回调函数捕获。控制台会打印出如下的报错信息。 12XMLHttpRequest cannot load http://api.alice.com.Origin http://api.bob.com is not allowed by Access-Control-Allow-Origin. 服务器回应的其他CORS相关字段如下。1234Access-Control-Allow-Methods: GET, POST, PUTAccess-Control-Allow-Headers: X-Custom-HeaderAccess-Control-Allow-Credentials: trueAccess-Control-Max-Age: 1728000 Access-Control-Allow-Methods该字段必需，它的值是逗号分隔的一个字符串，表明服务器支持的所有跨域请求的方法。注意，返回的是所有支持的方法，而不单是浏览器请求的那个方法。这是为了避免多次”预检”请求。 Access-Control-Allow-Headers如果浏览器请求包括Access-Control-Request-Headers字段，则Access-Control-Allow-Headers字段是必需的。它也是一个逗号分隔的字符串，表明服务器支持的所有头信息字段，不限于浏览器在”预检”中请求的字段。 Access-Control-Allow-Credentials该字段与简单请求时的含义相同。 Access-Control-Max-Age该字段可选，用来指定本次预检请求的有效期，单位为秒。上面结果中，有效期是20天（1728000秒），即允许缓存该条回应1728000秒（即20天），在此期间，不用发出另一条预检请求。 浏览器的正常请求和回应一旦服务器通过了”预检”请求，以后每次浏览器正常的CORS请求，就都跟简单请求一样，会有一个Origin头信息字段。服务器的回应，也都会有一个Access-Control-Allow-Origin头信息字段。 下面是”预检”请求之后，浏览器的正常CORS请求。 1234567PUT /cors HTTP/1.1Origin: http://api.bob.comHost: api.alice.comX-Custom-Header: valueAccept-Language: en-USConnection: keep-aliveUser-Agent: Mozilla/5.0... 上面头信息的Origin字段是浏览器自动添加的。下面是服务器正常的回应。 12Access-Control-Allow-Origin: http://api.bob.comContent-Type: text/html; charset=utf-8 上面头信息中，Access-Control-Allow-Origin字段是每次回应都必定包含的。 与JSONP的比较CORS与JSONP的使用目的相同，但是比JSONP更强大。JSONP只支持GET请求，CORS支持所有类型的HTTP请求。JSONP的优势在于支持老式浏览器，以及可以向不支持CORS的网站请求数据。 WebSocket协议跨域WebSocket 是 HTML5 开始提供的一种在单个 TCP 连接上进行全双工通讯的协议。 WebSocket 使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据。在 WebSocket API 中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。 原生WebSocket API使用起来不太方便，我们使用Socket.io，它很好地封装了webSocket接口，提供了更简单、灵活的接口，也对不支持webSocket的浏览器提供了向下兼容。 前端代码 123456789101112131415161718192021222324&lt;div&gt; &lt;input type="text" id="inputText"&gt;&lt;/div&gt;&lt;script src="example.com/socket.io.js"&gt;&lt;/script&gt;&lt;script&gt;var socket = io('http://www.peanutyu.site');// 连接成功处理socket.on('connect', function() &#123; // 监听服务端消息 socket.on('message', function(msg) &#123; console.log('data from server: ---&gt; ' + msg); &#125;); // 监听服务端关闭 socket.on('disconnect', function() &#123; console.log('Server socket has closed.'); &#125;);&#125;);document.getElementById('inputText').onblur = function() &#123; socket.send(this.value);&#125;;&lt;/script&gt; Node Server123456789101112131415161718192021222324252627var http = require('http');var socket = require('socket.io');// 启http服务var server = http.createServer(function(req, res) &#123; res.writeHead(200, &#123; 'Content-type': 'text/html' &#125;); res.end();&#125;);server.listen('8080');console.log('Server is running at port 8080...');// 监听socket连接socket.listen(server).on('connection', function(client) &#123; // 接收信息 client.on('message', function(msg) &#123; client.send('hello：' + msg); console.log('data from client: ---&gt; ' + msg); &#125;); // 断开处理 client.on('disconnect', function() &#123; console.log('Client socket has closed.'); &#125;);&#125;); HTML5 postMessageHTML5 window.postMessage是一个安全的、基于事件的消息API。 在需要发送消息的源窗口调用postMessage方法就可以向外发送消息。其中源窗口可以是以下的几种情况。 全局的window对象 （var win = window） 文档窗口中的iframe（var win = iframe.documentWindow） 当前文档窗口的父窗口（var win = window.parent） JavaScript打开的新窗口（var win = window.open()） 发送消息1win.postMessage(msg, targetOrigin); postMessage接受两个参数 msg, 需要发送的消息,可以是一切JavaScript参数；如字符串、数字、对象、数组等。 targetOrigin, 这个参数为需要消息的目标域,假设www.peanutyu.site的网页上需要往www.peanut.site的网页上传递消息，那么这个参数就是http://www.peanut.site/。如果目标窗口的协议、主机地址或端口这三者的任意一项不匹配targetOrigin提供的值，那么消息就不会被发送；只有三者完全匹配，消息才会被发送。该值也可以传入一个字符串&#39;*&#39;表示无限制） 接收消息12345window.addEventListener('message', function receiveMessage(event) &#123; if (event.origin === 'http://www.peanut.site') &#123; console.log(event.data); // 传递的数据 &#125;&#125;, false); event的属性有 data 从其他 window 中传递过来的对象。 origin 调用 postMessage 时消息发送方窗口的 origin . 这个字符串由 协议、“://“、域名、“ : 端口号”拼接而成。例如 “https://example.org (隐含端口 443)”、“http://example.net (隐含端口 80)”、“http://example.com:8080”。请注意，这个origin不能保证是该窗口的当前或未来origin，因为postMessage被调用后可能被导航到不同的位置。 source 对发送消息的窗口对象的引用; 您可以使用此来在具有不同origin的两个窗口之间建立双向通信。 Nginx代理Nginx配置12345678910server&#123; # 监听9999端口 listen 9999; # 域名是localhost server_name localhost; #凡是localhost:9999/api这个样子的，都转发到真正的服务端地址http://localhost:9871 location ^~ /api &#123; proxy_pass http://localhost:9871; &#125; &#125; 请求的时候直接用回前端这边的域名http://localhost:9999，这就不会跨域，然后Nginx监听到凡是localhost:9099/api这个样子的，都转发到真正的服务端地址http://localhost:98711axios.get('http://localhost:9999/api/iframePost', params).then(result =&gt; console.log(result)).catch(() =&gt; &#123;&#125;); Nginx转发的方式似乎很方便！但这种使用也是看场景的，如果后端接口是一个公共的API，比如一些公共服务获取天气什么的，前端调用的时候总不能让运维去配置一下Nginx，如果兼容性没问题（IE 10或者以上），CROS才是更通用的做法吧。 Node中间层接口转发目前中后台比较常用的接口处理方式。Spa页面通过服务器根路由或者/index渲染由前端来控制路由跳转。剩下/api路径下开发我们的接口请求。 后台配置1234567891011121314151617181920212223242526// 页面路由router.get('/index', async function(ctx, next) &#123; // 打包JS时间戳 let timeT = moment().valueOf(); // 配置基本版本号 let buildPath = config.assetsServerName; try &#123; let env = process.env.NODE_ENV; // 从Redis内获取的JS版本号 let configInfo = await RedisService.getServerConfigInfoByEnv(env); if(configInfo) &#123; let info = JSON.parse(configInfo); if(info &amp;&amp; info['build']) &#123; buildPath = info['build'].url; &#125; &#125; // 渲染SPA页面 await ctx.render('index', &#123;assetsPath: buildPath, tag: timeT&#125;); &#125; catch(e) &#123; // 报错渲染配置版本号SPA页面 await ctx.render('index', &#123;assetsPath: buildPath, tag: timeT&#125;); &#125;&#125;)// 接口路由router.get('/api/list', xxController.methods); // 获取列表方法、 具体逻辑处理通过controller完成 前端代码1234567_reqData() &#123; axios.get('/api/list', &#123;&#125;).then(result =&gt; &#123;console.log(result)&#125;).catch(() =&gt; &#123;&#125;);&#125;componentWillMount() &#123; this._reqData();&#125; 参考链接 跨域资源共享 CORS 详解]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入浅出BFC]]></title>
    <url>%2FCss%2F%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BABFC%2F</url>
    <content type="text"><![CDATA[BFC是什么？ BFC全称（Block Formatting Context）块级格式化上下文是Web页面的可视化CSS渲染的一部分，它是块级盒子布局过程产生的区域，也是浮动层元素进行交互的区域，可以让处于BFC内部的元素与外部的元素相互隔离，使内外的元素不会相互影响。 BFC如何创建？以下任意一条都会创建块级格式化上下文。 浮动元素（元素的float不是none） 绝对定位元素（元素的position为absolute或fixed） 行内块级元素（元素的display为inline-block） 表格单元格（元素的display为table-cell,HTML表格单元格默认为该值） 表格标题（元素的display为table-caption,HTML表单标题格默认为该值） overflow值不为visible的块元素 更多创建BFC布局的方式可以参考MDN这里就不一一赘述了。 BFC布局和普通文档流布局区别BFC布局规则 浮动的元素会被父级计算高度当父级元素触发了BFC的时候 非浮动元素不会覆盖浮动元素位置（非浮动元素触发了BFC） margin不会传递给父级（父级触发了BFC） 属于同一BFC的两个相邻元素上下margin会重叠 普通文档流布局规则 浮动的元素是不会被父级计算高度 非浮动元素会覆盖浮动元素的位置 margin会传递给父级元素 两个相邻元素上下的margin会重叠 BFC的约束规则 内部的Box会在垂直方向上一个接一个的放置 （Block元素会与父元素同宽，所以会垂直排列） 垂直方向上的距离由margin决定 每个元素的左外边距与包含块的左边界相接触（从左向右），即使浮动元素也是如此。（这说明BFC中子元素不会超出他的包含块，而position为absolute的元素可以超出他的包含块边界）（浮动元素的位置也是会尽量接近左上方或右上方） BFC的区域不会与float的元素区域重叠 计算BFC的高度时，浮动子元素也参与计算 BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面元素，反之亦然]]></content>
      <categories>
        <category>Css</category>
      </categories>
      <tags>
        <tag>Css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从输入URL回车之后发生了什么]]></title>
    <url>%2F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%9B%9E%E8%BD%A6%E4%B9%8B%E5%90%8E%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%2F</url>
    <content type="text"><![CDATA[从输入URL回车之后发生了什么从输入URL到页面展示总体来说分为以下一个步骤： 输入地址 根据地址栏输入的地址发生DNS解析查询其IP。 通过IP地址与服务器建立TCP连接。 客户端向服务端发送HTTP请求，如果服务器返回以 301 之类的重定向，浏览器根据相应头中的 location 再次发送请求 服务器收到请求并响应HTTP请求，处理请求生成 html 代码，返回给浏览器。 浏览器开始解析渲染页面并显示 关闭连接 输入地址当我们开始在浏览器中输入网站时，浏览器其实就已经在智能的匹配一些可能的url了，它会从书签、历史记录等地方找到已经输入的url字符串所对应的url,然后给出智能提示，让你可以补全url地址。对于google的chrome浏览器，它甚至会从缓存中把网页展示出来；换言之当我们输入地址时，页面就出来了。 DNS解析DNS(Domain Name System)服务是和HTTP协议一样位于应用层的协议。它提供域名到IP地址之间的解析。用户通常使用主机名或域名来访问对方的计算机，而不是通过IP地址访问。 DNS解析的过程就是寻找哪台机器上有你需要资源的过程。当你在浏览器中输入一个地址时，例如www.baidu.com，其实不是百度网站真正意义上的地址。互联网上每一台计算机的唯一标识是它的IP地址，但是IP地址并不方便记忆。用户更喜欢用方便记忆的网址去寻找互联网上的其它计算机，也就是上面提到的百度的网址。所以互联网设计者需要在用户的方便性与可用性方面做一个权衡，这个权衡就是一个网址到IP地址的转换，这个过程就是DNS解析。它实际上充当了一个翻译的角色，实现了网址到IP地址的转换。 什么是DNS 域名系统（英文：Domain Name System，缩写：DNS）是互联网的一项服务。它作为将域名和IP地址相互映射的一个分布式数据库，能够使人更方便地访问互联网。DNS使用TCP和UDP端口53。当前，对于每一级域名长度的限制是63个字符，域名总长度则不能超过253个字符。 –维基百科 域名解析的过程是逐级查询的 浏览器缓存: 首先会向浏览器的缓存中读取上一次访问的记录，在chrome可以通过地址栏中输入chrome://net-internals/#dns查看缓存的当前状态 操作系统缓存: 查找存储在系统运行内存中的缓存。在mac中可以通过下面的命令清除系统中的DNS缓存。 1dscacheutil -flushcache 在host文件中查找：如果在缓存中都查找不到的情况下，就会读取系统中预设的host文件中的设置。 路由器缓存：有些路由器也有DNS缓存的功能，访问过的域名会存在路由器上。 ISP DNS缓存：互联网服务提供商（如中国电信）也会提供DNS服务，比如比较著名的 114.114.114.114，在本地查找不到的情况下，就会向ISP进行查询，ISP会在当前服务器的缓存内查找是否有记录，如果有，则返回这个IP，若没有，则会开始向根域名服务器请求查询。 顶级DNS服务器/根DNS服务器：根域名收到请求后，会判别这个域名(.com)是授权给哪台服务器管理,并返回这个顶级DNS服务器的IP。请求者收到这台顶级DNS的服务器IP后，会向该服务器发起查询，如果该服务器无法解析，该服务器就会返回下一级的DNS服务器IP（nicefilm.com），本机继续查找，直到服务器找到(www.nicefilm.com)的主机。 我们可以通过dig命令查看域名解析的记录 1dig math.stackexchange.com 我们重点看返回的应答，会看到有四条记录，返回了该网址的四个IP12345;; ANSWER SECTION:math.stackexchange.com. 34 IN A 151.101.129.69math.stackexchange.com. 34 IN A 151.101.65.69math.stackexchange.com. 34 IN A 151.101.1.69math.stackexchange.com. 34 IN A 151.101.193.69 34是TTL的值，表示该域名的缓存时间，即该时间内不用重新查询。A是该DNS查询的记录类型，表示返回一个IPv4格式的地址。还有其他记录类型诸如 NS（返回查询的服务器地址）、AAAA（返回IPV6格式的地址）、CNAME（域名的别名）等。 解析过程DNS解析是一个递归查询的过程。 上述图片是查找www.google.com的IP地址过程。首先在本地域名服务器中查询IP地址，如果没有找到的情况下，本地域名服务器会向根域名服务器发送一个请求，如果根域名服务器也不存在该域名时，本地域名会向com顶级域名服务器发送一个请求，依次类推下去。直到最后本地域名服务器得到google的IP地址并把它缓存到本地，供下次查询使用。从上述过程中，可以看出网址的解析是一个从右向左的过程: com -&gt; google.com -&gt; www.google.com。但是你是否发现少了点什么，根域名服务器的解析过程呢？事实上，真正的网址是www.google.com.，并不是我多打了一个.，这个.对应的就是根域名服务器，默认情况下所有的网址的最后一位都是.，既然是默认情况下，为了方便用户，通常都会省略，浏览器在请求DNS的时候会自动加上，所有网址真正的解析过程为: . -&gt; .com -&gt; google.com. -&gt; www.google.com.。 DNS优化了解了DNS的过程，可以为我们带来哪些？上文中请求到google的IP地址时，经历了8个步骤，这个过程中存在多个请求(同时存在UDP和TCP请求，为什么有两种请求方式，请自行查找)。如果每次都经过这么多步骤，是否太耗时间？如何减少该过程的步骤呢？那就是DNS缓存。 DNS缓存DNS存在着多级缓存，从离浏览器的距离排序的话，有以下几种: 浏览器缓存，系统缓存，路由器缓存，IPS服务器缓存，根域名服务器缓存，顶级域名服务器缓存，主域名服务器缓存。 在你的chrome浏览器中输入:chrome://dns/，你可以看到chrome浏览器的DNS缓存。 系统缓存主要存在/etc/hosts(Linux系统)中: DNS负载均衡不知道大家有没有思考过一个问题: DNS返回的IP地址是否每次都一样？如果每次都一样是否说明你请求的资源都位于同一台机器上面，那么这台机器需要多高的性能和储存才能满足亿万请求呢？其实真实的互联网世界背后存在成千上百台服务器，大型的网站甚至更多。但是在用户的眼中，它需要的只是处理他的请求，哪台机器处理请求并不重要。DNS可以返回一个合适的机器的IP给用户，例如可以根据每台机器的负载量，该机器离用户地理位置的距离等等，这种过程就是DNS负载均衡，又叫做DNS重定向。大家耳熟能详的CDN(Content Delivery Network)就是利用DNS的重定向技术，DNS服务器会返回一个跟用户最接近的点的IP地址给用户，CDN节点的服务器负责响应用户的请求，提供所需的内容。 TCP连接TCP 是一种面向有连接的传输层协议。 它可以保证两端（发送端和接收端）通信主机之间的通信可达。 它能够处理在传输过程中丢包、传输顺序乱掉等异常情况；此外它还能有效利用宽带，缓解网络拥堵。 拿到了要请求的资源服务器IP后，浏览器通过操作OS的socket与服务器进行TCP连接（一般来说操作系统已经封装好了TCP/IP等协议，提供套接字给应用去使用，该部分涉及到标准网络模型的知识，另外再开篇拓展。） 这个连接就是我们所熟知的三次握手 本机主动打开连接 第一次，本机将标识位 SYN 置为 1, seq = x(Sequence number)发送给服务端。此时本机状态为SYN-SENT 第二次，服务器收到包之后，将状态切换为SYN-RECEIVED，并将标识位 SYN 和 ACK都置为1, seq = y, ack = x + 1, 并发送给客户端。 第三次，客户端收到包后，将状态切换为ESTABLISHED，并将标识位ACK置为1，seq = x + 1, ack = y + 1, 并发送给服务端。服务端收到包之后，也将状态切换为ESTABLISHED。 需要注意的一点是，有一些文章对ACK标识位 和 ack（Acknowledgement Number）的解释比较模糊，有一些画图的时候干脆就写在一起了。虽然这两者有关联，但不是同一个东西，搞清楚这个误区可以更方便去理解。还有一些会把第二次握手描述成两个包（比如某百科……），实际上这也是不正确的 标识位ACK置为1 表示我已确认收到seq为x的包，并回复确认序号ack = x + 1 而SYN表示这是我第一次随机生成seq的序列x，此后我每次发送的包都会在上一次发送的基础上增加y（有数据的时候，y是数据的长度，没有的时候y = 1）。所以，当seq已初始化完成之后，没必要再把SYN置为1理解了这两点，也就不难理解为什么三次握手分别是SYN、ACK/SYN、ACK了。 标识位（TCP FLAG）TCP的头部固定有20个字节，其中分配了6bits给TCP FLAG，组合起来用来表示当前包的类型。分别是URGACKPSHRSTSYNFIN（CWRECE放在保留位，暂不考虑） URG：紧急指针，用于将要发送的包标识为“紧急”，这意味着不必等待前段数据被响应处理完即可发送给接收端。 ACK：确认标识，用于表示对数据包的成功接收。 PSH：推送标识，表示这个数据包应该被立即发送，不需要等待额外的数据。 RST：reset标识，用来异常关闭连接。 SYN：同步标识，表示TCP连接已初始化。 FIN：完成标识，用于拆除上一个SYN标识。一个完整的TCP连接过程一定会有SYN 和 FIN包。至此我们了解了一个TCP 连接的过程，通道通了，是时候利用这个通道送东西了。我们从传输层再回到应用层。 发送HTTP请求 超文本传输协议（英文：HyperText Transfer Protocol，缩写：HTTP）是一种用于分布式、协作式和超媒体信息系统的应用层协议[1]。HTTP是万维网的数据通信的基础。设计HTTP最初的目的是为了提供一种发布和接收HTML页面的方法。通过HTTP或者HTTPS协议请求的资源由统一资源标识符（Uniform Resource Identifiers，URI）来标识。 在应用层，浏览器会分析这个url，并设置好请求报文发出。请求报文中包括请求行、请求头、空行、请求主体。https默认请求端口443， http默认80。 请求行：请求行中包括请求的方法，路径和协议版本。 请求头：请求头中包含了请求的一些附加的信息，一般是以键值的形式成对存在，比如设置请求文件的类型accept-type，以及服务器对缓存的设置。 空行：协议中规定请求头和请求主体间必须用一个空行隔开 请求主体：对于post请求，所需要的参数都不会放在url中，这时候就需要一个载体了，这个载体就是请求主题。 服务端响应HTTP请求在接收和解释请求消息后，服务器返回一个HTTP响应消息。HTTP 响应由三个部分组成，分别是：状态行、消息报头、响应正文。状态代码：由三位数字组成，第一个数字定义了响应的类别，且有五种可能取值： 1xx：指示信息–表示请求已接收，继续处理 2xx：成功–表示请求已被成功接收、理解、接受 3xx：重定向–要完成请求必须进行更进一步的操作 4xx：客户端错误–请求有语法错误或请求无法实现 5xx：服务器端错误–服务器未能实现合法的请求 常见状态代码、状态描述、说明： 200 OK ：客户端请求成功 400 Bad Request ：客户端请求有语法错误，不能被服务器所理解 401 Unauthorized ：请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用 403 Forbidden ：服务器收到请求，但是拒绝提供服务 404 Not Found ：请求资源不存在，eg：输入了错误的URL 500 Internal Server Error ：服务器发生不可预期的错误 503 Server Unavailable ：服务器当前不能处理客户端的请求，一段时间后可能恢复正常 HTTP缓存HTTP 消息报头包括：普通报头、请求报头、响应报头、实体报头。具体不作介绍。响应正文：就是服务器返回的资源的内容 http缓存请求是浏览器的一个优化点，我们可以通过缓存来减少不必要的请求，进而加快页面的呈现。通过简单地设置http头部可以使用缓存的功能。一般来说有三种设置的方式 Last-Modify(响应头) + If-Modified-Since（请求头）服务器在返回资源的时候设置Last-Modify当前资源最后一次修改的时间，浏览器会把这个时间保存下来，在下次请求的时候，请求头部If-Modified-Since 会包含这个时间，服务端收到请求后，会比对资源最后更新的时间是否在If-Modified-Since设置的时间之后，如果不是，返回304状态码，浏览器将从缓存中获取资源。反之返回200和资源内容。 ETag（响应头） + If-None-Match（请求头）根据资源标识符来确定文件是否存在修改，服务器每一次返回资源，都会在Etag中存放资源的标识符，浏览器收到这个标识符，在下一次请求的时候将标识符放在If-None-Match中，服务端将判断是否匹配，如果不匹配，返回200以及新的资源，反之返回304，浏览器从缓存中获取资源 Cache-Control/Expires(响应头)首先这不是一种方法，而是协议更替中的一种演化。在http 1.0的时代，我们基于Pragma 和 Expires 控制缓存的生命周期。我们可以通过设置Pragma为no-cache关闭缓存功能，同样也可以在Expires中设置一个缓存失效的时间。需要注意的是，这个失效的时间是相对于服务器的实践而言的，如果人为地改变了客户端的时间，是会导致缓存失效的。 所以，为了解决这个问题，HTTP1.1的协议加入了Cache-Control，通过设置Cache-Control的max-age可以控制缓存的周期。在这个周期内，资源是新鲜的，浏览器再一次需要使用资源的时候，就不会发出请求了。 渲染页面在浏览器没有完整接受全部 HTML 文档时，它就已经开始显示这个页面了，不同浏览器可能解析的过程不太一样，这里我们只介绍 WebKit 的渲染过程。 &lt;!– * 通过HTML解析器解析HTML文档，构建一个DOM Tree，同时通过CSS解析器解析HTML中存在的CSS，构建Style Rules，两者结合形成一个Attachment。 通过Attachment构造出一个呈现树（Render Tree） Render Tree构建完毕，进入到布局阶段（layout/reflow），将会为每个阶段分配一个应出现在屏幕上的确切坐标。 最后将全部的节点遍历绘制出来后，一个页面就展现出来了。 –&gt; 解析HTML，构建 DOM 树 解析 CSS ，生成 CSS 规则树 合并 DOM 树和 CSS 规则，生成 render 树 布局 render 树（ Layout / reflow ），负责各元素尺寸、位置的计算 绘制 render 树（ paint ），绘制页面像素信息 浏览器会将各层的信息发送给 GPU，GPU 会将各层合成（ composite ），显示在屏幕上 需要注意的是，这是一个渐进的过程，呈现引擎为了力求显示的及时，会在文档请求不完全的情况下就开始渲染页面，同时，如果在解析的过程中遇到script的时候，文档的解析将会停止下来，立即解析执行脚本，如果脚本是外部的，则会等待请求完成并解析执行。所以，为了不阻塞页面地呈现，一般会把script脚本放在文档的最后。 在最新的HTML4和HTML5规范中，也可以将脚本标注为defer，这样就不会停止文档解析，而是等到解析结束后才执行。HTML5 增加了一个选项，可将脚本标记为async，以便由其他线程解析和执行。 连接关闭现在的页面为了优化请求的耗时，默认都会开启持久连接（keep-alive），那么一个TCP连接确切关闭的时机，是这个tab标签页关闭的时候。这个关闭的过程就是著名的四次挥手。关闭是一个全双工的过程，发包的顺序的不一定的。一般来说是客户端主动发起的关闭，过程如下。 假如最后一次客户端发出的数据seq = x, ack = y; 客户端发送一个FIN置为1的包，ack = y， seq = x + 1，此时客户端的状态为 FIN_WAIT_1 服务端收到包后，状态切换为CLOSE_WAIT发送一个ACK为1的包， ack = x + 2。客户端收到包之后状态切换为FNI_WAIT_2 服务端处理完任务后，向客户端发送一个 FIN包，seq = y; 同时将自己的状态置为LAST_ACK 客户端收到包后状态切换为TIME_WAIT，并向服务端发送ACK包，ack = y + 1，等待2MSL后关闭连接。为什么客户端等待2MSL？MSL: 全程Maximum Segment Lifetime，中文可以翻译为报文最大生存时间。等待是为了保证连接的可靠性，确保服务端收到ACK包，如果服务端没有收到这个ACK包，将会重发FIN包给客户端，而这个时间刚好是服务端等待超时重发的时间 + FIN的传输时间。]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈Object.defineProperty]]></title>
    <url>%2F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F%E6%B5%85%E8%B0%88object.defineProperty%2F</url>
    <content type="text"><![CDATA[Object属性描述符js对象内部有两种属性描述符 数据描述符和存取描述符（访问描述符）;描述符必须是两种形式之一；不能同时是两者。 注意事项数据描述符和存取描述符都具备configurable、enumerable属性。描述符不具备value，writetable，set和get任意一个关键字都被认作一个数据描述符。（value或writetable）和（get和set）不能同时存在，然后只要定义了set和get或其中一个都是一个存取描述符（描述符只能是其中一种）。 描述符可同时具有的键值 configurable enumerable value writetable get set 数据描述符 yes yes yes yes no no 存取描述符 yes yes no no yes yes 数据描述符 数据描述符是一个拥有可写或不可写值的属性 数据描述符有两个独有的属性(value, writeable)123456let People = &#123;&#125;;Object.defineProperty(People, &apos;name&apos;, &#123; value: &apos;peanut&apos;, writable: true, // 值是否可以发生改变&#125;);console.log(People.name); 这里的value就是我们给name这个属性赋的初始值，默认为undefined；我们打印People.name的结果为peanut。1234Object.defineProperty(People, &apos;age&apos;, &#123; writeable: true &#125;);console.log(People.age);People.age = 23;console.log(People.age); 这里我们第一次的打印结果就为默认值undefined，第二次打印结果为23.因为我们这时候writeable为true,代表这个值是可以修改的。 存取描述符 存取描述符是由一对 getter-setter 函数功能来描述的属性。 get: 一个给属性提供getter的方法，如果没有getter则为undefined。该方法返回值被用作属性值。默认为undefined。set: 一个给属性提供setter的方法，如果没有setter则为undefined。该方法将接受唯一参数，并将该参数的新值分配给该属性。默认值为undefined。 1234567891011121314let People = &#123;&#125;;let temp = null;Object.defineProperty(People, &apos;name&apos;, &#123; get: function() &#123; return temp; &#125;, set: function(value) &#123; temp = value; &#125;,&#125;);console.log(People.name); // nullPeople.name = &apos;peanut&apos;;console.log(People.name); // peanut Object.defineProperty的使用123456789101112131415161718192021222324252627282930const o = &#123;&#125;;// 在对象中添加一个属性与数据描述符的示例Object.defineProperty(o, &apos;a&apos;, &#123; value : 1, writable : true, enumerable : true, configurable : true,&#125;);// 对象o有了一个属性a, 值为1// 在对象中添加一个属性与存取描述符的示例let b;Object.defineProperty(o, &apos;b&apos;, &#123; get : function()&#123; return b; &#125;, set : function(newValue)&#123; b = newValue; &#125;, enumerable : true, configurable : true&#125;);o.b = 2;// 对象o拥有了属性b，值为2 1、writable、enumerable、configurable为false的情况 wirtable：变量不可再被重新赋值 enumerable： 变量不能在遍历器例如for…in和Object.keys()中被读取出来，不可被遍历 configurable：变量不可配置，定义为false之后，不能再为该变量定义配置否则报错。变量被删除(delete)、修改都会无效。2、如果对象的属性是存取描述符，只会调用定义了的set和get（configurable、enumrable）在给一个对象属性做赋值操作，在读取属性值时，这个赋值操作赋值的值会被忽略，会去调用定义的get方法的值]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[纯Css(Scroll Indicator)滚动指示器实现]]></title>
    <url>%2FCss%2F%E7%BA%AFcss%E6%BB%9A%E5%8A%A8%E8%BF%9B%E5%BA%A6%E6%9D%A1%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[Scroll Indicator称之为滚动指示器,是web页面中我们经常见到的一个效果。用户触发垂直方向上的滚动时，页面顶部会有一个类似进度条的效果，当内容滚动到页面最底部，则进度条填满页面的整个页面宽度。 Scroll IndicatorScroll Indicator：滚动指示器。通俗来说，就是当前可视区域距离页面顶部的占比。阮老师的《ECMAScript 6 入门》官网的每个章节的页面都使用了这样一个滚动指示器，效果如下图： Javascript的实现方法 页面加载完成之后，首先需要获取到页面文档高度（domHeight)、视窗高度（winHeight),则可计算成页面滚动到底部所需的高度scrollHeight = domHeight - winHeight以及可视区域距离页面顶部的高度scrollTop; 监听页面scroll事件，通过当前的scrollTop / scrollHeight * 100%, 即为进度条的百分比。 代码如下12345678var $window = $(window);var domHeight = $(document).height();var winHeight = $window.height();var scrollHeight = domHeight - winHeight;$window.on('scroll', function() &#123; var per = $(this).scrollTop() / scrollHeight; $('进度条dom').css(&#123; width: per * 100 + '%' &#125;);&#125;); 阮一峰老师es6官网的实现源码 123456789101112131415161718(function() &#123; var $w = $(window); var $prog2 = $('.progress-indicator-2'); var wh = $w.height(); var h = $('body').height(); var sHeight = h - wh; $w.on('scroll', function() &#123; window.requestAnimationFrame(function()&#123; var perc = Math.max(0, Math.min(1, $w.scrollTop() / sHeight)); updateProgress(perc); &#125;); &#125;); function updateProgress(perc) &#123; $prog2.css(&#123;width: perc * 100 + '%'&#125;); &#125;&#125;()); 实现代码方法大同小异，都是通过判断实际滚动距离与页面实际滚动高度的差值来进行比较。 Css的实现方法Css的实现方法主要是运用线性渐变来实现这个功能。首先假设我们的页面被包裹在body内，并且body是可以滚动的，我们可以给它添加一个从左下角到右上角的线性渐变。1234body &#123; background-image: linear-gradient(to right top, #ffcc00 50%, #eee 50%); background-repeat: no-repeat;&#125; 浅蓝色块的颜色变化已经可以展示出我们进度条的一些形状了。我们继续加上一个伪元素，把多余的部分遮住。加上之后的效果如下图：12345678910body::after &#123; content: ""; position: fixed; top: 5px; left: 0; bottom: 0; right: 0; background: rgba(0,0,0,.6); z-index: -1;&#125; 这里我们可以发现其实当页面滑到最底部的时候，我们的进度条并没有到达最底部。因为body的线性渐变高度设置了整个 body 的大小，我们调整一下渐变的高度： 12345body &#123; background-image: linear-gradient(to right top, #ffcc00 50%, #eee 50%); background-repeat: no-repeat; background-size: 100% calc(100% - 100vh + 5px);&#125; 这里使用了 calc 进行了运算，减去了 100vh，也就是减去一个屏幕的高度，这样渐变刚好在滑动到底部的时候与右上角贴合。而 + 5px 则是滚动进度条的高度，预留出 5px 的高度。 到现在为止这个用Css实现滚动进度条已经实现了，不过这个实现方法确有一些缺陷。 页面内容不能有背景色或背景图 body自身也不能有背景图 CSS更好的实现由于对角线性渐变不能写在body上，我们可以假设将他写在一个div上。张鑫旭大神给我们提供了一套更好的实现方案。 在标签内插入指示器元素：L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"left","width":150,"height":300,"mobile":{"show":true}},"log":false}); 1&lt;div class="indicator"&gt;&lt;/div&gt; 粘贴如下所示的CSS代码： 12345678910111213141516171819body &#123; position: relative;&#125;.indicator &#123; position: absolute; top: 0; right: 0; left: 0; bottom: 0; background: linear-gradient(to right top, teal 50%, transparent 50%) no-repeat; background-size: 100% calc(100% - 100vh); z-index: 1; pointer-events: none; mix-blend-mode: darken;&#125;.indicator::after &#123; content: ''; position: fixed; top: 5px; bottom: 0; right: 0; left: 0; background: #fff; z-index: 1;&#125; 这样一个更好的CSS滚动指示器效果就实现了。 这种更好的实现方法的核心在于mix-blend-mode: darken,也就是darken模式。darken混合模式的混合方式很好理解，两个颜色进行混合，哪个颜色深就使用哪个颜色。要知道所有的颜色里面最浅的就是白色，于是我们只要把我们的白色覆盖层的混合模式设置为darken，那必然最终呈现出来的颜色一定是覆盖层下面元素内容的颜色，换句话说我们的白色透明覆盖层变透明了。相关darken文章参考darken。 参考链接 更好的纯CSS滚动指示器技术实现]]></content>
      <categories>
        <category>Css</category>
      </categories>
      <tags>
        <tag>Css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记录移动端键盘弹起导致底部上浮解决方案]]></title>
    <url>%2F%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95%2F%E8%AE%B0%E5%BD%95%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%94%AE%E7%9B%98%E5%BC%B9%E8%B5%B7%E5%AF%BC%E8%87%B4%E5%BA%95%E9%83%A8%E4%B8%8A%E6%B5%AE%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[在实际开发过程中，我们经常会遇到各种不同的浏览器内核以及不同的手机型号导致的一些前端兼容性问题。其中在H5页面中，由于移动端键盘的多样性，导致很多时候我们在唤起小键盘时，我们的页面经常会遇到一些错乱的问题。 问题描述在最近的一次微信H5页面开发过程中，由于我们的整体页面是通过Header, Main, Footer三个组件拼接起来的；整体的高度是适配屏幕的百分之百，Main组件做内部的滚动，Header、以及Footer页面分别位于页面的最上方以及最下方。这时候我们focus到输入框中，一些小键盘是整体覆盖在H5页面上，所以并没有造成很大的影响；而一部分机型则是会将页面整体往上顶，这样会让我们的可视距离变得非常的少，并且我们的Footer也会被键盘整体顶上来；Main组件可以显示的内容变得几乎没有，这样显然是不行的，所以我们要做出调整。 解决思路在键盘弹起时，不让原本固定在底部的Footer被撑起，监听屏幕此时的实时高度,控制Footer的显示与否，达到将底部栏固定在底部的效果。 解决方案 (framework: weex vue.js)Html123&lt;yoga-footer v-if=&quot;showFooter&quot; name=&quot;talent-circle&quot;&gt;&lt;/yoga-footer&gt; JavaScript1234567891011121314151617181920212223242526272829303132import Footer from &apos;components/weex-footer&apos;;export default &#123; ... components: &#123; &apos;yoga-footer&apos;: Footer, &#125;, // data数据 data () &#123; return &#123; domHeight: document.documentElement.clientHeight || document.body.clientHeight, showHeight: document.documentElement.clientHeight || document.body.clientHeight, showFooter: true, &#125;; &#125;, // 监听showHeight变化 检测是否显示Footer watch: &#123; showHeight() &#123; if (this.domHeight &gt; this.showHeight) &#123; this.showFooter = false; &#125; else &#123; this.showFooter = true; &#125; &#125;, &#125;, // 绑定页面resize事件改变showHeight mounted() &#123; window.onresize = () =&gt; (() =&gt; &#123; this.showHeight = document.documentElement.clientHeight || document.body.clientHeight; &#125;)(); &#125; 总结解决移动端键盘弹起导致底部上浮的最佳方案就是监听我们的resize事件，由于一些环境下的键盘是破坏了我们原有的页面结构，所以我们的resize事件也发生了改变，可以快速的响应页面高度改变发生的一些问题；而在一些IOS机型，小键盘弹起是不会影响页面布局触发resize事件的，所以也不会有其他副作用的出现。]]></content>
      <categories>
        <category>问题记录</category>
      </categories>
      <tags>
        <tag>问题记录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git高级用法——git cherry-pick]]></title>
    <url>%2FGit%2Fgit%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95%E2%80%94%E2%80%94git-cherry-pick%2F</url>
    <content type="text"><![CDATA[前言最近正巧看了一些面试题，其中有一道令我比较好奇，也就是我们今天要说到的git cherry-pick;我们在简历当中都会写上精通或者熟练掌握git工作技巧。但绝大多数人也许只掌握一些简单的类似git status | pull | push | log等操作,又或是使用sourcetree等一些辅助工具来支持我们日常的工作需求，这篇博客主要记录和git cherry-pick与之相关的git操作。 使用场景及其作用git cherry-pick可以选择某一个分支的一个或几个commit(s)来进行操作（操作的对象就是commit）。假设这样一个场景，产品提出某个功能需求，你开发完毕，然后commit了；第二天，产品通知你那个功能可能不要了，于是你把代码reset回去；又过了几天，产品告诉你说，之前reset的功能我们要重新加回来；这时候应该怎么办？代码在reset之后又进行开发了其他的功能，已经修改过并且有了新的commit，你是应该重新开发还是回退呢？ 这种时候就是git cherry-pick发挥效果的时候了。 git log查询commit id 的查询可以使用git log查询（查询版本的历史），最简单的语法就是1git log 详细的git log语法如下:1234567891011git log [&lt;options&gt;] [&lt;since&gt;..&lt;until&gt;] [[--] &lt;path&gt;...] 主要参数选项如下： -p：按补丁显示每个更新间的差异 --stat：显示每次更新的修改文件的统计信息 --shortstat：只显示--stat中最后的行数添加修改删除统计 --name-only：尽在已修改的提交信息后显示文件清单 --name-status：显示新增、修改和删除的文件清单 --abbrev-commit：仅显示SHA-1的前几个字符，而非所有的40个字符 --relative-date：使用较短的相对时间显示（例如：&quot;two weeks ago&quot;） --graph：显示ASCII图形表示的分支合并历史 --pretty：使用其他格式显示历史提交信息 git refloggit reflog 可以查看所有分支的所有操作记录（包括已经被删除的 commit 记录和 reset 的操作） 场景一首先我们通过git log查看所有的commit信息。 commit的信息很简单，就是做了3个功能开发，每个功能对应一个commit的提交，分别是feature-1 =&gt; feature-4。假设这时候可能产品说功能2、3、4不需要上线了。我们需要将代码回滚到1上面。 1git reset --hard dbe570bf1bf9c5f5777b39b242f90e3eb16a1aec 现在我们看到我们的commit信息只剩下了最开始的feature-1功能还保留在上面了；此时产品需要我们上线一个称之为功能5的commit,一个星期后产品需要我们把之前的2、3、4重新合并到代码里头上线；这时候我们需要怎么做呢？ 首先我们可以看到现在的git log打印出来的信息是只有feature-1和feature-5提交的代码 这时候我们首先通过git reflog命令查看分支上的所有操作记录 这时候要记好两个值：c8f4403和45ec9b1，他们分别是feature-5和feature-4的hash码。然后执行回滚，回到feature-4上。 1git reset --hard 45ec9b1 现在我们回到了feature-4上，如下图 但是我们现在feature-5的代码丢失了，如何将它找回来呢？这时候就需要我们的git cherry-pick。刚刚我们知道git cherry-pick的hash码为c8f4403 1git cherry-pick c8f4403 输入好了之后feature-5的代码就找回来了。 期间可能会产生一些代码的冲突，只需要按正在的步骤解决就好了。 最后的结果如下图 到这里feature-1到feature-5的代码就找回来了。这就是git cherry-pick的用法。 场景二在一个分支branch1开发，进行多次提交，这时我们切换到branch2，想把之前的branch1分支上的commit复制过来。 首先我们切换到branch1分支，然后查看提交历史记录，可以用sourceTree查看，也可以使用命令Git log 例如的我branch1 git log如下图 这时候我只想把branch-1-feature-1的提交复制到branch2里面，只需要切换到branch2分支，然后执行1git cherry-pick e8ae0307b4d2775922c0a2cbd3930ef4c4dca353 branch2 git log如下图 git cherry-pick 也可以同时合并多个branch； 假设branch2需要合并branch1的branch-1-feature-1，branch-1-feature-2；就可以使用 1git cherry-pick e8ae0307b4d2775922c0a2cbd3930ef4c4dca353,cc6b772ea79ecf54f9df18dd8f0ebf868dfe9170 参考链接 女神的侧颜—git时光穿梭机]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>实战经验</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git Commit 规范以及 emoji 列表]]></title>
    <url>%2FGit%2FGit%20commit%20%E8%A7%84%E8%8C%83%E4%BB%A5%E5%8F%8A%20emoji%20%E5%88%97%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[分支 master分支为主分支（保护分支），不能直接在master上进行修改代码或提交,通过MR(merge Request)或者PR(pull Request)的方式进行提交。 preview分支为预发分支， 所有测试完成需要上线的功能合并到该分支 develop、 test分支为测试分支，所有开发完成需要提交测试的功能合并到该分支 feature/xxx分支为功能开发分支，根据不同需求创建独立的功能分支，开发完成后合并到develop或test分支 hotfix分支为bug修复分支，需要根据实际情况对已发布的版本进行漏洞修复 Tag采用三段式，v版本.里程碑.序号，例如v1.0.0 架构升级或架构重大调整，修改第1位 新功能上线或者模块大的调整，修改第2位 bug修复上线，修改第3位 Commit message的格式每次提交，Commit message 都包括三个部分：header，body 和 footer。 12345&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;// 空一行&lt;body&gt;// 空一行&lt;footer&gt; 其中，Header 是必需的，Body 和 Footer 可以省略。不管是哪一个部分，任何一行都不得超过72个字符（或100个字符）。这是为了避免自动换行影响美观。 HeaderHeader部分只有一行，包括三个字段：type（必需）、scope（可选）和subject（必需）。 typetype用于说明 commit 的类别，只允许使用下面7个标识。 feat：新功能（feature） fix：修补bug docs：文档（documentation） style： 格式（不影响代码运行的变动） refactor：重构（即不是新增功能，也不是修改bug的代码变动） test：增加测试 chore：构建过程或辅助工具的变动如果type为feat和fix，则该 commit 将肯定出现在 Change log 之中。其他情况（docs、chore、style、refactor、test）由你决定，要不要放入 Change log，建议是不要。 scopescope用于说明 commit 影响的范围，比如数据层、控制层、视图层等等，视项目不同而不同。 subjectsubject是 commit 目的的简短描述，不超过50个字符。 以动词开头，使用第一人称现在时，比如change，而不是changed或changes 第一个字母小写 结尾不加句号（.） BodyBody 部分是对本次 commit 的详细描述，可以分成多行。下面是一个范例。1234567More detailed explanatory text, if necessary. Wrap it to about 72 characters or so. Further paragraphs come after blank lines.- Bullet points are okay, too- Use a hanging indent 有两个注意点。（1）使用第一人称现在时，比如使用change而不是changed或changes。（2）应该说明代码变动的动机，以及与以前行为的对比。 FooterFooter 部分只用于两种情况。 不兼容变动如果当前代码与上一个版本不兼容，则 Footer 部分以BREAKING CHANGE开头，后面是对变动的描述、以及变动理由和迁移方法。 12345678910111213141516BREAKING CHANGE: isolate scope bindings definition has changed. To migrate the code follow the example below: Before: scope: &#123; myAttr: &apos;attribute&apos;, &#125; After: scope: &#123; myAttr: &apos;@&apos;, &#125; The removed `inject` wasn&apos;t generaly useful for directives so there should be no code using it 关闭 Issue如果当前 commit 针对某个issue，那么可以在 Footer 部分关闭这个 issue 。 1Closes #234 Revert还有一种特殊情况，如果当前 commit 用于撤销以前的 commit，则必须以revert:开头，后面跟着被撤销 Commit 的 Header。123revert: feat(pencil): add &apos;graphiteWidth&apos; optionThis reverts commit 667ecc1654a317a13331b17617d973392f415f02. Body部分的格式是固定的，必须写成This reverts commit &lt;hash&gt;.，其中的hash是被撤销 commit 的 SHA 标识符。 如果当前 commit 与被撤销的 commit，在同一个发布（release）里面，那么它们都不会出现在 Change log 里面。如果两者在不同的发布，那么当前 commit，会出现在 Change log 的Reverts小标题下面。 CommitizenCommitizen是一个撰写合格 Commit message 的工具。 安装命令如下。 1$ npm install -g commitizen 然后，在项目目录里，运行下面的命令，使其支持 Angular 的 Commit message 格式。 1$ commitizen init cz-conventional-changelog --save --save-exact 以后，凡是用到git commit命令，一律改为使用git cz。这时，就会出现选项，用来生成符合格式的 Commit message。 validate-commit-msgvalidate-commit-msg 用于检查 Node 项目的 Commit message 是否符合格式。 它的安装是手动的。首先，拷贝下面这个JS文件，放入你的代码库。文件名可以取为validate-commit-msg.js。 接着，把这个脚本加入 Git 的 hook。下面是在package.json里面使用 ghooks，把这个脚本加为commit-msg时运行。 12345&quot;config&quot;: &#123; &quot;ghooks&quot;: &#123; &quot;commit-msg&quot;: &quot;./validate-commit-msg.js&quot; &#125;&#125; 然后，每次git commit的时候，这个脚本就会自动检查 Commit message 是否合格。如果不合格，就会报错。 123$ git add -A $ git commit -m &quot;edit markdown&quot; INVALID COMMIT MSG: does not match &quot;&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;&quot; ! was: edit markdown 生成 Change log如果你的所有 Commit 都符合 Angular 格式，那么发布新版本时， Change log 就可以用脚本自动生成 生成的文档包括以下三个部分。 New features Bug fixes Breaking changes. 每个部分都会罗列相关的 commit ，并且有指向这些 commit 的链接。当然，生成的文档允许手动修改，所以发布前，你还可以添加其他内容。 conventional-changelog 就是生成 Change log 的工具，运行下面的命令即可。 123$ npm install -g conventional-changelog$ cd my-project$ conventional-changelog -p angular -i CHANGELOG.md -w 上面命令不会覆盖以前的 Change log，只会在CHANGELOG.md的头部加上自从上次发布以来的变动。 如果你想生成所有发布的 Change log，要改为运行下面的命令。 1$ conventional-changelog -p angular -i CHANGELOG.md -w -r 0 为了方便使用，可以将其写入package.json的scripts字段。 12345&#123; &quot;scripts&quot;: &#123; &quot;changelog&quot;: &quot;conventional-changelog -p angular -i CHANGELOG.md -w -r 0&quot; &#125;&#125; 以后，直接运行下面的命令即可。1$ npm run changelog git commit中使用emojiemoji规范格式git commit 时，提交信息遵循以下格式：12345:emoji1: :emoji2: 主题提交信息主体Ref &lt;###&gt; 初次提交示例：1git commit -m &quot;:tada: Initialize Repo&quot; emoji指南 emoji emoji代码 Commit说明 🎨 (调色板) :art: 改进代码结构/代码格式 ⚡️ (闪电) :zap: 提升性能 🐎 (赛马) :racehorse: 提升性能 🔥 (火焰) :fire: 移除代码或文件 🐛 (bug) :bug: 修复 bug 🚑 (急救车) :ambulance: 重要补丁 ✨ (火花) :sparkles: 引入新功能 📝 (铅笔) :pencil: 撰写文档 🚀 (火箭) :rocket: 部署功能 💄 (口红) :lipstick: 更新 UI 和样式文件 🎉 (庆祝) :tada: 初次提交 ✅ (白色复选框) :white_check_mark: 增加测试 🔒 (锁) :lock: 修复安全问题 🍎 (苹果) :apple: 修复 macOS 下的问题 🐧 (企鹅) :penguin: 修复 Linux 下的问题 🏁 (旗帜) :checked_flag: 修复 Windows 下的问题 🔖 (书签) :bookmark: 发行/版本标签 🚨 (警车灯) :rotating_light: 移除 linter警告 🚧 (施工) :construction: 工作进行中 💚 (绿心) :green_heart: 修复 CI 构建问题 ⬇️ (下降箭头) :arrow_down: 降级依赖 ⬆️ (上升箭头) :arrow_up: 升级依赖 👷 (工人) :construction_worker: 添加 CI 构建系统 📈 (上升趋势图) :chart_with_upwards_trend: 添加分析或跟踪代码 🔨 (锤子) :hammer: 重大重构 ➖ (减号) :heavy_minus_sign: 减少一个依赖 🐳 (鲸鱼) :whale: Docker 相关工作 ➕ (加号) :heavy_plus_sign: 增加一个依赖 🔧 (扳手) :wrench: 修改配置文件 🌐 (地球) :globe_with_meridians: 国际化与本地化 ✏️ (铅笔) :pencil2: 修复 typo 参考文献 Commit message 和 Change log 编写指南]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>实战经验</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Weex常见问题解析]]></title>
    <url>%2FWeex%2Fweex%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[什么是 Weex？ Weex 是使用流行的 Web 开发体验来开发高性能原生应用的框架。 Weex 致力于使开发者能基于通用跨平台的 Web 开发语言和开发经验，来构建 Android、ios 和 Web 应用。简单来说，在集成了 WeexSDK 之后，你可以使用 JavaScript 语言和前端开发经验来开发移动应用。 Weex 渲染引擎与 DSL 语法层是分开的，Weex 并不强依赖任何特定的前端框架。目前 Vue.js 和 Rax 这两个前端框架被广泛应用于 Weex 页面开发，同时 Weex 也对这两个前端框架提供了最完善的支持。Weex 的另一个主要目标是跟进流行的 Web 开发技术并将其和原生开发的技术结合，实现开发效率和运行性能的高度统一。在开发阶段，一个 Weex 页面就像开发普通网页一样；在运行时，Weex 页面又充分利用了各种操作系统的原生组件和能力。 为什么选择 Weex？Weex带给我们的收益 迭代速度快，快速上线 Weex环境下完全Native体验 Bundle资源大小对比H5小很多 富交互体验，长列表性能好 上手快且简单、一次编写三段兼容 H5 WEEX Native 开发成本 低 中 高 维护更新 简单 简单 复杂 用户体验 差 优 优 发版审核 不需要 不需要 需要 跨平台性 优 优 差 Weex开发踩坑通用样式1、图片1、Weex提供了image组件,但只支持远程图片链接(在新weex sdk 已经解决)。图片必须添加宽、高属性否则会不显示出来。2、避免在image标签上使用v-for，否则会导致安卓上图片渲染异常（如slider中的图片）12345678&lt;slider class=&quot;activity&quot; :autoPlay=&quot;true&quot; interval=&quot;4000&quot; @change=&quot;sliderChange&quot;&gt; &lt;div class=&quot;activity-cell&quot; v-for=&quot;(item, index) in bannerList&quot; :key=&quot;index&quot; @click=&quot;clickInBanner(item)&quot;&gt; &lt;image class=&quot;activity-wrap-bg&quot; resize=&quot;cover&quot; :src=&quot;imageRes.bannerBgImg&quot;&gt;&lt;/image&gt; &lt;image class=&quot;activity-wrap-image&quot; :src=&quot;item.pictureUrl&quot;&gt;&lt;/image&gt; &lt;/div&gt;&lt;/slider&gt; 2、borderWeex不支持使用border创建三角形，web可以正常显示，而ios和android上显示的是矩形，建议使用图片代替 webios、android 3、scale设置为0问题transform: scale(0)会导致文档流内所有事件扩散到整个html结构，导致文档流事件全部无效。只有脱离文档流的元素（absolute等）可以点击；常用可以设置transform: scale(0,1)，并使元素隐藏起来。 4、input标签高度问题安卓环境中，当input高度设置小于60px时，会导致输入框光标不会显示出来。（ios、web正常） 5、v-if问题在做一些操作切换状态时（如按钮点击置灰），应尽量避免使用v-if，使用v-if会闪，且部分安卓机子会发生不可描述的事情（如部分三星机型会出现按钮文字居顶），可采用添加class的方式 6、透明度目前仅ios支持box-shadow属性，android暂不支持，可以使用图片代替。每个元素只支持设置一个阴影效果，不支持多个阴影同时作用于一个元素。and在日常开发中阴影最好使用图片来代替，避免出现未知的问题。以下是涉及到颜色的相关属性对透明度的支持度列表 属性 IOS Android H5 color 支持 支持 支持 opacity 支持 支持 支持 border-color 支持 支持 支持 box-shadow 支持 不支持 支持 background-color 支持 支持 支持 background-image 不支持 支持 支持 7、Weex不支持样式简写123456789.border &#123; margin: 0 10px; // 错误 margin-right: 10px; margin-left: 10px; // 正确 border: 1px solid #000; // 错误 border-width: 1px; border-style: solid; border-color: #000; // 正确&#125; 8、 点击态项目比较常见的点击态多半是透明度的变化，如按钮、列表、链接等，css的做法是添加伪类 (:active)，Weex中也同样支持，但是Weex需要在原样式中添加 opacity:1,否则点击后回不到初始状态；此外，:active使用时,background-image在ios下会失效。12345678910111213&lt;template&gt; &lt;div class=&quot;btn&quot;&gt; &lt;text&gt;下载&lt;/text&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt; .btn &#123; opacity: 1; // 必须添加 &#125; .btn:active &#123; opacity: 0.5; &#125;&lt;/style&gt; 9、 文本截断文本从限制一行到不限制可以使用lines:0来控制;123456789101112131415161718192021222324252627&lt;template&gt; &lt;text class=&quot;text&quot; @click=&quot;onClickText&quot; :style=&quot;textStyle&quot;&gt; 这是一段测试文本，这是一段测试文本，这是一段测试文本，这是一段测试文本，这是一段测试文本，这是一段测试文本，这是一段测试文本，这是一段测试文本，这是一段测试文本，这是一段测试文本，这是一段测试文本，这是一段测试文本，这是一段测试文本，这是一段测试文本，这是一段测试文本，这是一段测试文本，这是一段测试文本，这是一段测试文本，这是一段测试文本，这是一段测试文本，这是一段测试文本， &lt;/text&gt;&lt;/template&gt;&lt;style scoped&gt;.text &#123; text-overflow: ellipsis; lines: 1;&#125;&lt;/style&gt;&lt;script&gt; export default &#123; data () &#123; return &#123; textStyle: &#123;&#125;, &#125;; &#125;, methods: &#123; onClickText() &#123; this.textStyle = &#123; lines: 0, &#125;; &#125;, &#125;, &#125;&lt;/script&gt; 10、html顺序在不同设备上的显示例如有a、b、c、d 四层结构，其中a、b、c均为absolute定位,z-index由大到小，d为普通结构，我们知道在css中a层应该是处于最上方，d在最下方，那么在weex中表现如何呢？12345678&lt;template&gt; &lt;div&gt; &lt;div&gt;A(绿)&lt;/div&gt; &lt;div&gt;B(蓝)&lt;/div&gt; &lt;div&gt;C(紫)&lt;/div&gt; &lt;div&gt;D(红)&lt;/div&gt; &lt;/div&gt;&lt;/template&gt; webios、android 可以看到web和ios、android的表现不一致，ios、android中是以代码中dom顺序来依次添加的，和z-index无关，后面加载的视图会覆盖前面的视图。所以要保证web、ios、android三端表现一致，改变dom书写顺序即可。 12345678&lt;template&gt; &lt;div&gt; &lt;div&gt;D(红)&lt;/div&gt; &lt;div&gt;C(紫)&lt;/div&gt; &lt;div&gt;B(蓝)&lt;/div&gt; &lt;div&gt;A(绿)&lt;/div&gt; &lt;/div&gt;&lt;/template&gt; 11、安卓下遮挡问题安卓下容器如果设置了宽高，那么子元素不能超出容器范围 12、微信环境输入框失焦时，当前页面的视图偏移量未回复到初始位置。微信环境输入框收起会改变页面dom结构布局，可以采取捕获失去焦点事件， 执行window.scrollTo(0, 0); 13、微信环境下超过一屏的长图在加载时渲染不出来可以对图片的父容器（scroller、 list）设置一个背景颜色，即可成功加载。 14、渐变weex不支持径向渐变radial-gradient,只支持创建线性渐变。并且只支持两种颜色的渐变，渐变方向如下： to right: 从左向右渐变 to left: 从右向左渐变 to bottom: 从上向下渐变 to top: 从下向上渐变 to bottom right: 从左上角向右下角渐变 to top left: 从右下角向左上角渐变 注意 background-image优先级高于background-color，这意味着同时设置background-image和background-color,后者会被覆盖。 background不支持简写。 15、富文本weex在0.20版本添加一个新的标签richtext即富文本标签。但在之前的版本内weex是不支持富文本功能的，基本富文本功能都是使用图片来代表，因为weex的字体标签只有text，并且都是weex所有的标签结构都是弹性布局；但是weex也提供了一个方案，即在weex中空格也是占据一定空间的，所以可以支持一些特定的富文本功能。 富文本 1234567891011121314151617181920212223&lt;template&gt; &lt;div&gt; &lt;image class=&quot;tag-image&quot; :src=&quot;data.userType | typeImg&quot; :style=&quot;&#123; top: `$&#123;getEnvValue(17,18,13)&#125;px`&#125;&quot;&gt;&lt;/image&gt; &lt;text class=&quot;item-title&quot;&gt;&#123;&#123;&apos; &apos; + getEnvValue(&apos; &apos;,&apos;&apos;,&apos; &apos;)+ data.title&#125;&#125;&lt;/text&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; methods: &#123; // 根据环境不同返回不同的三个值 getEnvValue(webValue, iOSValue, androidValue) &#123; if (this.isWeb) &#123; return webValue; &#125; else if (this.isIos) &#123; return iOSValue; &#125; else if (this.isAndroid) &#123; return androidValue; &#125; return iOSValue; &#125;, &#125;&#125;&lt;/script&gt; 输入事件1、输入框不能清空内容需要清空输入框内已经输入的内容时，不能直接将绑定的值置为空，而是应该先隐藏输入框内显示的值，在一次渲染之后将在将值置为空。12345678910111213141516171819202122232425262728293031323334353637&lt;template&gt; &lt;div class=&quot;input-wrap&quot;&gt; &lt;wxs-icon name=&quot;search&quot; size=&apos;40px&apos; color=&apos;#b2b2b2&apos;&gt;&lt;/wxs-icon&gt; &lt;input :value=&quot;searchKeyWord&quot; returnKeyType=&quot;search&quot; @focus=&quot;onInputFocus&quot; @blur=&quot;onInputBlur&quot; @input=&quot;onInputInput&quot; @return=&quot;onInputReturn&quot; class=&quot;input-hint&quot; ref=&quot;input&quot; placeholder-color=&quot;#cccccc&quot; :singleline=&quot;true&quot; :lines=&quot;1&quot; /&gt; &lt;div class=&quot;erase&quot; @click=&quot;onClickErase&quot;&gt; &lt;wxs-icon v-if=&quot;isInputFocus || isWeb&quot; name=&quot;erase&quot; size=&apos;36px&apos; color=&apos;#b2b2b2&apos; &gt;&lt;/wxs-icon&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data() &#123; return &#123; searchKeyWord: &apos;&apos;, &#125;; &#125;, methods: &#123; onClickErase() &#123; this.searchKeyWord = &apos; &apos;; this.$nextTick(() =&gt; &#123; this.searchKeyWord = &apos;&apos;; &#125;); &#125;, &#125;&#125;&lt;/script&gt; 2、Weex input输入框组件 在安卓下input事件BUG当使用v-model绑定值时，还原到绑定值原始状态时，无法触发input事件，此时还影响到v-model的绑定。在android上的表现为对输入框的input事件进行监听；打开页面选中输入框，对输入框输入一串文字，此时成功的触发了input事件。按键盘上的删除，最初也是成功的触发input事件，当最后一个字符被删除时，input事件并不会触发。如果不使用value来设置值，改使用v-model，也会出现这样的情况。通过查阅资料，发现这个是weex android sdk存在的一个坑点（作者没太接触过安卓开发）https://segmentfault.com/q/1010000010238162/a-1020000010276364里面给出了一张修改源码的方式来解决该BUG。主要问题是在WXInput的父类AbstractEditComponent类中, mIgnoreNextOnInputEvent 这个变量在组件初始化的时候被设置为了TRUE，导致了第一次输入input内容显示不出来。使用上一个问题的方法也可以成功的解决该问题，也可以将searchKeyWord的初始值置为undefined也可以很好的规避该问题。 组件命令组件命名应避免使用JS关键字和保留字，以及weex提供的组件名称，如用loading作为组件名称，在ios与android中将呈现空白。 12345&lt;template&gt; &lt;div&gt; &lt;Loading&gt;&lt;/Loading&gt; /* 改用其他名称 */ &lt;/div&gt;&lt;/template&gt; 自定义slider组件weex本身提供了slider组件，但轮播图指示器（indicator）只能修改颜色与位置，大小却无法更改，所以需要自定义slider组件12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;template&gt; &lt;!-- 首页banner区块 --&gt; &lt;div class=&quot;activity-wrap&quot; :style=&quot;&#123; top: (topSafeAreaHeight + 123) + &apos;px&apos; &#125;&quot;&gt; &lt;slider class=&quot;activity&quot; :autoPlay=&quot;true&quot; interval=&quot;4000&quot; @change=&quot;sliderChange&quot;&gt; &lt;div class=&quot;activity-cell&quot; v-for=&quot;(item, index) in bannerList&quot; :key=&quot;index&quot; @click=&quot;clickInBanner(item)&quot;&gt; &lt;image class=&quot;activity-wrap-bg&quot; resize=&quot;cover&quot; :src=&quot;imageRes.bannerBgImg&quot;&gt;&lt;/image&gt; &lt;image class=&quot;activity-wrap-image&quot; :src=&quot;item.pictureUrl&quot;&gt;&lt;/image&gt; &lt;/div&gt; &lt;/slider&gt; &lt;div class=&quot;slider-indicator-wrap&quot; v-if=&quot;bannerList &amp;&amp; bannerList.length &gt; 1&quot;&gt; &lt;div v-for=&quot;(icon, index) in bannerList&quot; :key=&quot;index&quot; ref=&quot;activeSliderKey&quot; class=&quot;slider-indicator&quot; :class=&quot;[index === 0 ? &apos;slider-indicator-left&apos; : &apos;&apos;]&quot; &gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; ..., methods: &#123; // 首页banner切换回调 sliderChange(&#123; index &#125;) &#123; const self = this; if (self.bannerList.length &gt; 0) &#123; for (let i = 0; i &lt; self.bannerList.length; i += 1) &#123; animation.transition(self.$refs.activeSliderKey[i], &#123; styles: &#123; backgroundColor: &apos;rgba(255, 255, 255, 0.3)&apos;, &#125;, delay: 0, &#125;); &#125; animation.transition(self.$refs.activeSliderKey[index], &#123; styles: &#123; backgroundColor: &apos;rgba(255, 255, 255)&apos;, &#125;, delay: 0, &#125;); &#125; &#125;, &#125;,&#125;&lt;/script&gt; 动画weex不支持帧动画，但本身自带的transition可以传入对应的style，并通过setInterval来控制动画循环播放 animation.js123456789101112131415161718192021222324252627282930313233343536const animation = weex.requireModule(&apos;animation&apos;);export function transition(el, opts, dd) &#123; const duration = dd || 400; if (!el) &#123; return Promise.resolve(); &#125; return new Promise((resolve) =&gt; &#123; animation.transition(el, &#123; duration, timingFunction: &apos;linear&apos;, delay: 0, ...opts, &#125;, resolve); &#125;);&#125;export function run(el) &#123; transition(el, &#123; styles: &#123; transform: &apos;scale(1.02)&apos;, &#125;, &#125;, 100).then(() =&gt; &#123; transition(el, &#123; styles: &#123; transform: &apos;scale(1.08)&apos;, &#125;, &#125;, 200); &#125;).then(() =&gt; &#123; transition(el, &#123; styles: &#123; transition: &apos;scale(1)&apos;, &#125;, &#125;, 300); &#125;);&#125; page.vue123456789101112131415&lt;template&gt; &lt;div ref=&quot;btn&quot;&gt;&lt;/btn&gt;&lt;/template&gt;&lt;script&gt;export default &#123; ... mounted() &#123; setTimeout(() =&gt; &#123; setInterval(() =&gt; &#123; animation.run(this.$refs.btn); &#125;, 600); &#125;, 300); &#125;,&#125;&lt;/script&gt; 参考链接 企鹅电竞weex实践——UI开发篇 weex 中Android的v-model双向绑定 输入第一个字符时无响应]]></content>
      <categories>
        <category>Weex</category>
      </categories>
      <tags>
        <tag>Weex</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[转]你不知道的JavaScript上卷读书笔记]]></title>
    <url>%2F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F%E8%BD%AC-%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JavaScript%E4%B8%8A%E5%8D%B7%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[链接：https://juejin.im/post/5bfaa2e26fb9a04a0440b0e4来源：掘金 第一部分 作用域和闭包第一章 作用域是什么 1.1 编译原理传统编译的三个步骤 1,分词/词法分析(Tokenizing/Lexing) : 这个过程会将由字符组成的字符串分解成(对编程语言来说)有意义的代码块，这些代码块被称为词法单元(token)。例如，考虑程序var a = 2;。这段程序通常会被分解成 为下面这些词法单元:var、a、=、2、;。空格是否会被当作词法单元，取决于空格在 这门语言中是否具有意义。 2,解析/语法分析(Parsing): 这个过程是将词法单元流(数组)转换成一个由元素逐级嵌套所组成的代表了程序语法结构的树。这个树被称为“抽象语法树”(Abstract Syntax Tree，AST)。var a = 2; 的抽象语法树中可能会有一个叫作 VariableDeclaration 的顶级节点，接下来是一个叫作Identifier(它的值是a)的子节点，以及一个叫作 AssignmentExpression 的子节点。AssignmentExpression 节点有一个叫作 NumericLiteral(它的值是 2)的子节点。 3,代码生成: 将 AST 转换为可执行代码的过程称被称为代码生成。这个过程与语言、目标平台等息息相关。抛开具体细节，简单来说就是有某种方法可以将 var a = 2; 的 AST 转化为一组机器指令，用来创建一个叫作 a 的变量(包括分配内存等)，并将一个值储存在 a 中。 说明: 此处只需记住第一步:分词/词法分析.第二步:解析/语法分析,得到抽象语法树(AST).第三步:代码生成,将抽象语法树转换为机器指令. JavaScript与传统编译的不同点: 1,JavaScript 引擎不会有大量的(像其他语言编译器那么多的)时间用来进行优化. 2,JavaScript与传统的编译语言不同，它不是在构建之前提前编译的，大部分情况下,它是在代码执行前的几微秒(甚至更短)进行编译. 3,JavaScript 引擎用尽了各种办法(比如 JIT，可以延 迟编译甚至实施重编译)来保证性能最佳。 4,JavaScript的编译结果不能在分布式系统中进行移植。 1.2 理解作用域1.2.1 演员表(代码编译到执行的参与者)首先介绍将要参与到对程序 var a = 2; 进行处理的过程中的演员们，这样才能理解接下来将要听到的对话。 引擎从头到尾负责整个 JavaScript 程序的编译及执行过程。 编译器引擎的好朋友之一，负责语法分析及代码生成等脏活累活(详见前一节的内容)。 作用域引擎的另一位好朋友，负责收集并维护由所有声明的标识符(变量)组成的一系列查询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限。1.2.2 对话(代码编译执行过程) 1.2.3 作用域的LHS查询和RHS查询由上图可知,引擎在获得编译器给的代码后,还会对作用域进行询问变量. 现在将例子改为var a = b;此时引擎会对变量a和变量b都向作用域进行查询.查询分为两种:LHS和RHS.其中L代表左.R代表右.即对变量a进行LHS查询.对变量b进行RHS查询. 单单从表象上看.LHS就是作用域对=左边变量的查询.RHS就是作用域对=右边变量的查询.但实际上并不是这么简单,首先LHS和RHS都是对变量进行查询,这也是我为什么要将例子从var a=2;改为var a=b;两者的区别是两者最终要查询到的东西并不一致.LHS是要查询到变量的声明(而不是变量的值),从而后面可以为其赋值.RHS是要查询到变量最终的值.还有一点,LHS 和 RHS 的含义是“赋值操作的左侧或右侧”并不一定意味着就是“= 赋值操作符的左侧或右侧”。赋值操作还有其他几种形式，因此在概念上最 好将其理解为“赋值操作的目标是谁(LHS)”以及“谁是赋值操作的源头(RHS)”.或者这样理解如果这段代码需要得到该变量的’源值’,则会进行RHS查询. 1.2.4 引擎和作用域的对话这部分比较简单就是通过拟人方式比喻引擎和作用域的合作过程.一句话概括就是,引擎进行LHS和RHS查询时都会找作用域要.1234function foo(a) &#123; console.log( a ); // 2&#125;foo( 2 ); 让我们把上面这段代码的处理过程想象成一段对话，这段对话可能是下面这样的。 引擎:我说作用域，我需要为 foo 进行 RHS 引用。你见过它吗?作用域:别说，我还真见过，编译器那小子刚刚声明了它。它是一个函数，给你。引擎:哥们太够意思了!好吧，我来执行一下 foo。引擎:作用域，还有个事儿。我需要为 a 进行 LHS 引用，这个你见过吗?作用域:这个也见过，编译器最近把它声名为 foo 的一个形式参数了，拿去吧。引擎:大恩不言谢，你总是这么棒。现在我要把 2 赋值给 a。引擎:哥们，不好意思又来打扰你。我要为 console 进行 RHS 引用，你见过它吗?作用域:咱俩谁跟谁啊，再说我就是干这个。这个我也有，console 是个内置对象。 给你。引擎:么么哒。我得看看这里面是不是有 log(..)。太好了，找到了，是一个函数。引擎:哥们，能帮我再找一下对 a 的 RHS 引用吗?虽然我记得它，但想再确认一次。作用域:放心吧，这个变量没有变动过，拿走，不谢。引擎:真棒。我来把 a 的值，也就是 2，传递进 log(..)。 1.3作用域嵌套当一个块或函数嵌套在另一个块或函数中时，就发生了作用域的嵌套。进而形成了一条作用域链.因此，在当前作用 域中无法找到某个变量时，引擎就会在外层嵌套的作用域中继续查找，直到找到该变量， 或抵达最外层的作用域(也就是全局作用域)为止。 当引擎需要对作用域进行查询时.引擎会从当前的执行作用域开始查找变量，如果找不到， 就向上一级继续查找。当抵达最外层的全局作用域时，无论找到还是没找到，查找过程都 会停止。 1.4 异常例子:12345function foo(a) &#123; console.log( a + b ); b = a;&#125;foo( 2 ); 如果 RHS 查询在所有嵌套的作用域中遍寻不到所需的变量，引擎就会抛出 ReferenceError 异常。例如上面例子中console.log(a+b)由于RHS此时是找不到b的值.故会抛出ReferenceError. 如果 RHS 查询找到了一个变量，但是你尝试对这个变量的值进行不合理的操作， 比如试图对一个非函数类型的值进行函数调用，或着引用 null 或 undefined 类型的值中的 属性，那么引擎会抛出另外一种类型的异常，叫作 TypeError。 当引擎执行 LHS 查询时，如果在顶层(全局作用域)中也无法找到目标变量，全局作用域中就会创建一个具有该名称的变量，并将其返还给引擎，前提是程序运行在非 “严格模式”下。例如上面例子中的b=a;. 在严格模式中 LHS 查询失败时，并不会创建并返回一个全局变量，引擎会抛出同 RHS 查询 失败时类似的 ReferenceError 异常。 1.5 LHS与RHS小结 LHS和RHS查询都是引擎对作用域的查询 LHS和RHS查询都是只对变量进行查询 LHS和RHS都会沿着作用域链进行查询,直到最上层的全局作用域.如果没找到的话,在非严格模式下,LHS则会在全局创建一个相同名称的变量.RHS则会抛出ReferenceError的异常. 如果查找的目的是对变量进行赋值，那么就会使用 LHS 查询;如果目的是获取变量的值，就会使用 RHS 查询。 LHS只是找到变量的容器而已,方便进行赋值 =操作符或调用函数时传入参数的操作都会导致关联作用域的赋值操作。此时都会进行LHS查询 RHS查询则需要找到变量的值. 第二章 词法作用域作用域分为两种工作模式: 1,词法作用域.是目前最为普遍的，被大多数编程语言所采用的模式.当然JavaScript也是使用的词法作用域. 2,动态作用域.使用较少,比如 Bash 脚本、Perl 中的一些模式等. 2.1 词法阶段词法阶段: 大部分标准语言编译器的第一个工作阶段叫作词法化(也叫单词化)。词法化的过程会对源代码中的字符进行检查，如果是有状态的解析过程，还会赋予单词语义。 词法作用域: 词法作用域就是定义在词法阶段的作用域也被称为静态作用域。即在JavaScript里作用域的产生是在编译器出来的第一阶段词法阶段产生的,并且是你在书写完代码时就已经确定了的. 词法作用域位置: 词法作用域位置范围完全由写代码期间函数所声明的位置来决定. 理解词法作用域及嵌套:看下例子:12345678910function foo(a) &#123; var b = a * 2; function bar(c) &#123; console.log( a, b, c ); &#125; bar( b * 3 ); &#125;foo( 2 ); // 2, 4, 12 在这个例子中有三个逐级嵌套的作用域。为了帮助理解，可以将它们分成3个逐级包含的”气泡作用域”。 1:包含着整个全局作用域，其中只有一个标识符:foo。 2:包含着 foo 所创建的作用域，其中有三个标识符:a、bar 和 b。 3:包含着 bar 所创建的作用域，其中只有一个标识符:c。 注意: 没有任何函数的气泡可以(部分地)同时出现在两个外部作用域的气泡中，就如同没有任何函数可以部分地同时出现在两个父级函数中一样。 引擎对作用域的查找:这一部分在上一节中已经说过,就是从当前作用域逐级向上,直到最上层的全局作用域.这里再进一步进行讲解.作用域查找会在找到第一个匹配的标识符时停止。在多层的嵌套作用域中可以定义同名的标识符，这叫作“遮蔽效应”(内部的标识符“遮蔽”了外部的标识符)。抛开遮蔽效应， 作用域查找始终从运行时所处的最内部作用域开始，逐级向外或者说向上进行，直到遇见第一个匹配的标识符为止。 注意: 全局变量会自动成为全局对象(比如浏览器中的 window对象)的属性，因此可以不直接通过全局对象的词法名称，而是间接地通过对全局对象属性的引 用来对其进行访问。例如:window.a 通过这种技术可以访问那些被同名变量所遮蔽的全局变量。但非全局的变量如果被遮蔽了，无论如何都无法被访问到。 词法作用域查找只会查找一级标识符，比如 a、b 和 c。如果代码中引用了 foo.bar.baz，词法作用域查找只会试图查找 foo 标识符，找到这个变量后，对象属性访问规则会分别接管对 bar 和 baz 属性的访问。 2.2 欺骗词法欺骗词法: 引擎在运行时来“修改”(也可以说欺骗)词法作用域.或者说就是在引擎运行时动态地修改词法作用域(本来在编译词法化就已经确定的). 欺骗词法的两种机制:(下面这两种机制理解了解即可,不推荐实际开发使用) 2.2.1 evalJavaScript 中的 eval(..) 函数可以接受一个字符串为参数，并将其中的内容视为好像在书写时就存在于程序中这个位置的代码。即将eval放在该词法作用域,然后eval携带的代码就会动态加入到该词法作用域. 通过下面的例子加深理解:123456function foo(str, a) &#123; eval( str ); // 欺骗! console.log( a, b );&#125;var b = 2;foo( "var b = 3;", 1 ); // 1, 3 eval(..) 调用中的 “var b = 3;” 这段代码会被当作本来就在那里一样来处理。由于那段代码声明了一个新的变量 b，因此它对已经存在的 foo(..) 的词法作用域进行了修改。当 console.log(..) 被执行时，会在 foo(..) 的内部同时找到 a 和 b，但是永远也无法找到外部的 b。因此会输出“1, 3”而不是正常情况下会输出的“1, 2”。 注意: eval(..) 通常被用来执行动态创建的代码.可以据程序逻辑动态地将变量和函数以字符形式拼接在一起之后传递进去。 在严格模式下,eval(…)无法修改所在的作用域。 与eval(…)类似,setTimeout(..)和 setInterval(..) 的第一个参数可以是字符串，字符串的内容可以被解释为一段动态生成的函数代码。 new Function(..) 函数的行为也很类似，最后一个参数可以接受代码字符串，并将其转化为动态生成的函数(前面的参数是这个新生成的函数的形参)。这种构建函数的语法比 eval(..) 略微安全一些，但也要尽量避免使用。12var sum = new Function("a", "b", "return a + b;");console.log(sum(1, 1111)); //1112 2.2.2 with(不推荐实际使用)例子:12345678910111213141516171819function foo(obj) &#123; with (obj) &#123; a = 2; &#125;&#125;var o1 = &#123; a: 3&#125;;var o2 = &#123; b: 3&#125;;foo( o1 );console.log( o1.a ); // 2foo( o2 );console.log( o2.a ); // undefinedconsole.log( a ); // 2——不好，a 被泄漏到全局作用域上了! 起初你会觉得o1的a属性被with里的a进行了词法引用被遮蔽了成为了2.而o2没有a属性,此时with不能进行词法引用,所以此时o2.a就会变成undefined.但是,为什么最后console.log(a)会为2?因为在执行foo(o2)时,with会对其中的a=2进行LHS查询,但它在o2作用域,foo()作用域,全局作用域都没找到,因此就创建了一个全局变量a并随后赋值2. 总的来说,with就是将一个没有或有多个属性的对象处理为一个完全隔离的词法作用域，因此这个对象的属性也会被处理为定义在这个作用域中的词法标识符。 注意: 使用 eval(..) 和 with 的原因是会被严格模式所影响(限制)。with 被完全禁止，而在保留核心功能的前提下，间接或非安全地使用 eval(..) 也被禁止了。 2.2.3 性能JavaScript 引擎会在编译阶段进行数项的性能优化。其中有些优化依赖于能够根据代码的词法进行静态分析，并预先确定所有变量和函数的定义位置，才能在执行过程中快速找到标识符。但是eval(..) 和 with会在运行时修改或创建新的作用域，以此来欺骗其他在书写时定义的词法作用域。这么做就会导致引擎无法知道eval和with它们对词法作用域进行什么样的改动.只能对部分不进行处理和优化!因此如果代码中大量使用 eval(..) 或 with，那么运行起来一定会变得非常慢!。 2.3 小结 词法作用域是在你书写代码时就已经决定了的.在编译的第一阶段词法分析阶段产生词法作用域.此时词法作用域基本能够知道全部标识符在哪里以及是如何声明的，从而能够预测在执行过程中如何对它 们进行查找。 eval(..) 和 with。前者可以对一段包含一个或多个声明的“代码”字符串进行演算，并借此来修改已经存在的词法作用域(在运行时)。后者本质上是通过将一个对象的引用当作作用域来处理，将对象的属性当作作用域中的标识符来处理，从而创建了一个新的词法作用域(同样是在运行时)。 一般不要在实际代码中使用eval(…)和with,因为不仅危险,而且会造成性能问题! 第三章 函数作用域和块作用域3.1 函数中的作用域 JavaScript 具有基于函数的作用域，一般情况下每声明 一个函数都会创建一个函数作用域. 函数作用域的含义是指，属于这个函数的全部变量都可以在整个函数的范围内使用及复用(事实上在嵌套的作用域中也可以使用)。这样的好处是JavaScript 变量可以根据需要改变值类型。 3.2 隐藏内部实现因为 子级函数作用域可以直接访问父级函数作用域里的标识符; 父级函数作用域不能直接访问子级函数作用域里的标识符. 所以用函数声明对代码进行包装，实际上就是把这些代码“隐藏”起来了。 为什么要将代码进行”隐藏”?因为最小授权或最小暴露原则。这个原则是指在软件设计中，应该最小限度地暴露必 要内容，而将其他内容都“隐藏”起来，比如某个模块或对象的 API 设计。隐藏的好处: 实现代码私有化,减少外部对内部代码的干扰,保持其稳定性. 规避冲突: 可以避免同名标识符之间的冲突， 两个标识符可能具有相同的名字但用途却不一样，无意间可能造成命名冲突。冲突会导致 变量的值被意外覆盖。那么一般规避冲突的手段有哪些? 全局命名空间: 变量冲突的一个典型例子存在于全局作用域中。当程序中加载了多个第三方库时，如果它们没有妥善地将内部私有的函数或变量隐藏起来，就会很容易引发冲突。这些库通常会在全局作用域中声明一个名字足够独特的变量，通常是一个对象。这个对象被用作库的命名空间，所有需要暴露给外界的功能都会成为这个对象(命名空间)的属性，而不是将自己的标识符暴漏在顶级的词法作用域中。 2.模块管理: 另外一种避免冲突的办法和现代的模块机制很接近，就是从众多模块管理器中挑选一个来 使用。实际上就是我们常用的amd,commonjs,import模块机制. 3.3 函数作用域函数声明与函数表达式:123function foo() &#123; ...&#125; 我们知道函数foo内的变量和函数被隐藏起来了,是不会对全局作用域造成污染.但是变量名foo仍然存在于全局作用域中,会造成污染.那有什么方法能避免函数名的污染呢?那就是作为函数表达式,而不是一个标准的函数声明.这样函数名只存在于它自己的函数作用域内,而不会存在于其父作用域,这样就没有了污染.举个函数声明的例子:123456var a = 2;(function foo()&#123; var a = 3; console.log( a ); // 3 &#125;)(); console.log( a ); // 2 当我们用()包裹一个函数,并立即执行.此时这个包装函数声明是从(function开始的而不是从function关键字开始.这样foo就会被当做一个函数表达式,而不是一个函数声明(即foo不会存在于父级作用域中).回到上面的例子中,全局作用域是访问不到foo的,foo只存在于它自己的函数作用域中. 补充: 什么是函数声明和函数表达式首先我们得了解JS声明函数的三种方式: 函数表达式(Function Expression): 将函数定义为表达式语句（通常是变量赋值,也可以是自调用形式）的一部分。通过函数表达式定义的函数可以是命名的，也可以是匿名的。因为它可以没有函数名,因此常被用作匿名函数.如果有,其函数名也只存在自身的函数作用域.并且函数表达式不能以“function”开头.函数表达式可以存储在变量或者对象属性里. (在函数声明前加上运算符是可以将其转化为函数表达式的.例如!,+,-,().举个例子:!function(){console.log(1)}()的结果是1,并不会报错) 函数声明(Function Declaration): 函数声明是一种独立的结构,它会声明一个具名函数,并必须以function开头. 且函数声明会进行函数提升.使它能在其所在作用域的任意位置被调用,即后面的代码中可以将此函数通过函数名赋值给变量或者对象属性. Function()构造器: 即使用Function构造器创建函数.不推荐这种用法, 容易出问题123456789101112131415//Function()构造器var f =new Function()// 函数表达式var f = function() &#123; console.log(1); &#125;// 函数声明function f ()&#123; console.log(2);&#125;console.log(f())//思考一下,这里会打印出什么 怎么区分函数声明和函数表达式:看 function 关键字出现在声明中的位置(不仅仅是一行代码，而是整个声明中的位置)。如果 function 是声明中的第一个词，那么就是一个函数声明，否则就是一个函数表达式。例如上例中,是从(开始而不是function. 补充: 上面这段是原书的解释,我觉得这个解释并不完全,这里给出我自己的解释. 表象区别:和它说的一样,只要是以function开头进行声明,并且含有函数名的就一定是函数声明. 内在区别:其实我在上面补充两者的定义时已经说得很清楚了,我再对比总结下. 函数提升:函数声明,会将整个函数进行提升.而函数表达式则不会提升,它是在引擎运行时进行赋值，且要等到表达式赋值完成后才能调用。 函数表达式是可以没有函数名的,如果有,它的函数名也只存在于自身的作用域,var f = function fun(){console.log(fun)}其他地方是没有的.这也避免了全局污染,也方便递归. 3.3.1 匿名和具名函数表达式可以是匿名的，而函数声明则不可以省略函数名.有函数名的就是具名函数,没有函数名的就是匿名函数. 匿名函数的缺点: 匿名函数在栈追踪中不会显示出有意义的函数名，使得调试很困难。 如果没有函数名，当函数需要引用自身时只能使用已经过期的arguments.callee引用，比如在递归中。另一个函数需要引用自身的例子，是在事件触发后事件监听器需要解绑自身。 匿名函数省略了对于代码可读性/可理解性很重要的函数名。一个描述性的名称可以让代码不言自明。 所以给函数表达式指定一个函数名可以有效解决以上问题。始终给函数表达式命名是一个最佳实践. PS: 个人意见是如果函数表达式有赋值给变量或属性名或者就是一次性调用的.其实是没必要加上函数名.因为代码里取名本来就很难,取不好反而会造成误解. 3.3.2 立即执行函数表达式比如 (function foo(){ .. })()。第一个 ( ) 将函数变成表达式，第二个 ( ) 执行了这个函数。这就是立即执行函数表达式,也被称为IIFE，代表立即执行函数表达式 (Immediately Invoked Function Expression); IIFE可以具名也可以匿名.好处和上面提到的一样.IIFE还可以是这种形式(function(){ .. }()).这两种形式在功能上是一致的。 3.4 块作用域函数作用域是JavaScript最常见的作用域单元,有时我们仅会将var赋值变量在if或for的{…}内使用,而不会在其他地方使用.但它仍然会对外层的函数作用域造成污染.这个时候就会希望能有一个作用域能将其外部的函数作用域隔开,声明的变量仅在此作用域有效.块作用域(通常就是{…}包裹的内部)就可以帮我们做到这点. 从 ES3 发布以来，JavaScript 中就有了块作用域，而 with 和 catch 分句就是块作用域的两个小例子。 3.4.1 with我们在第 2 章讨论过 with 关键字。它不仅是一个难于理解的结构，同时也是块作用域的一个例子(块作用域的一种形式)，用 with 从对象中创建出的作用域仅在 with 声明中而非外部作用域中有效。 3.4.2 try/catchtry/catch 的 catch 分句会创建一个块作用域，其中声明的变量仅在 catch 内部有效。1234567try &#123; undefined(); // 执行一个非法操作来强制制造一个异常&#125;catch (err) &#123; console.log( err ); // 能够正常执行! &#125;console.log( err ); // ReferenceError: err not found err 仅存在 catch 分句内部，当试图从别处引用它时会抛出错误。那么如果我们想用catch创建一个不是仅仅接收err的块作用域,该怎么做呢?1234try&#123;throw 2;&#125;catch(a)&#123; console.log( a ); // 2&#125;console.log( a ); // ReferenceError 这样就创建了一个块作用域,且a=2,仅在catch分句中存在.在ES6之前我们可以使用这种方法来使用块作用域. 3.4.3 letES6 引入了新的 let 关键字，提供了除 var 以外的另一种变量声明方式。let 关键字可以将变量绑定到所在的任意作用域中(通常是 { .. } 内部)。 用 let 将变量附加在一个已经存在的块作用域上的行为是隐式的。例如在if的{…}内用let声明一个变量.那什么是显式地创建块作用域呢?就是单独创建{}来作为let的块作用域.而不是借用if或者for提供的{}.例如{let a=2;console.log(a)}注意: 使用 let 进行的声明不会在块作用域中进行提升.块作用域的好处: 1,垃圾收集12345678910111213function process(data)&#123; // 在这里做点有趣的事情 &#125; var someReallyBigData=function()&#123; //dosomeing &#125; process(someReallyBigData); var btn=document.getElementById("my_button"); btn.addEventListener("click",function click(evt)&#123; alert("button click"); //假如我们在这里继续调用someReallyBigData就会形成闭包,导致不能垃圾回收(这段是书里没有,我加上方便理解的) &#125;,false); click 函数的点击回调并不需要 someReallyBigData 变量。理论上这意味着当 process(..) 执行后，在内存中占用大量空间的数据结构就可以被垃圾回收了。但是，由于 click 函数形成了一个覆盖整个作用域的闭包，JavaScript 引擎极有可能依然保存着这个结构(取决于具体实现)。但显式使用块作用域可以让引擎清楚地知道没有必要继续保存 someReallyBigData 了: 123456789101112function process(data)&#123; // 在这里做点有趣的事情 &#125; // 在这个块中定义的内容可以销毁了! &#123; let someReallyBigData = &#123; .. &#125;; process( someReallyBigData ); &#125; var btn=document.getElementById("my_button"); btn.addEventListener("click",function click(evt)&#123; alert("button click"); &#125;,false); let循环1234for (let i=0; i&lt;10; i++) &#123; console.log( i ); &#125;console.log( i ); // ReferenceError for 循环头部的 let 不仅将 i 绑定到了 for 循环的块中，事实上它将其重新绑定到了循环的每一个迭代中，确保使用上一个循环迭代结束时的值重新进行赋值。这样就避免了i对外部函数作用域的污染. 3.4.4 const除了 let 以外，ES6 还引入了 const，同样可以用来创建块作用域变量，但其值是固定的(常量)。之后任何试图修改值的操作都会引起错误。123456789var foo = true;if (foo) &#123; var a = 2; const b = 3; // 包含在 if 中的块作用域常量 a = 3; // 正常! b = 4; // 错误! &#125;console.log( a ); // 3console.log( b ); // ReferenceError! 3.5 小结函数是 JavaScript 中最常见的作用域单元。本质上，声明在一个函数内部的变量或函数会在所处的作用域中“隐藏”起来，可以有效地与外部作用域隔开. 但函数不是唯一的作用域单元。块作用域指的是变量和函数不仅可以属于所处的作用域，也可以属于某个代码块(通常指 { .. } 内部)即块作用域。ES6中就提供了let和const来帮助创建块作用域. 第四章 提升4.1 先有鸡(赋值)还是先有蛋(声明)考虑第一段代码123a = 2;var a; console.log( a ); 输出结果是2,而不是undefined 考虑第二段代码12console.log( a ); var a = 2; 输出结果是undefined,而不是ReferenceError考虑完以上代码,你应该会考虑这个问题.到底是声明(蛋)在前，还是赋值(鸡)在前? 4.2 编译器再度来袭编译器的内容,回忆一下，引擎会在解释 JavaScript 代码之前首先对其进行编译。编译阶段中的一部分工作就是找到所有的声明，并用合适的作用域将它们关联起来。 之后引擎会询问作用域,对声明进行赋值操作. 那么,在编译阶段找到所有的声明后,编译器又做了什么?答案就是提升以上节的第一段代码为例,当你看到 var a = 2; 时，可能会认为这是一个声明。但 JavaScript 实际上会将其看成两个声明:var a;和a = 2;。 第一个定义声明是在编译阶段进行的。第二个赋值声明会被留在原地等待执行阶段。在第一个声明在编译阶段时,编译器会对var a;声明进行提升(即把var a;置于所在作用域的最上面).而a = 2;则会保持所在位置不动.此时代码会变成123var a; a = 2;console.log( a ); 由此可知,在编译阶段,编译器会对声明进行提升.即先有蛋(声明)后有鸡(赋值)。哪些声明会被进行提升? 变量声明:例如上例中的var a;.不包括后面的a = 2;即不包含有赋值操作的声明. 函数声明:注意是函数声明,而不是函数表达式!(不清楚可以看前面的3.3节,我有详细说明).函数声明提升,是将整个函数进行提升,而不是仅仅函数名的提升. 4.3 函数优先函数声明和变量声明都会被提升。但是一个值得注意的细节(这个细节可以出现在有多个“重复”声明的代码中)是函数会首先被提升，然后才是变量。考虑以下代码:12345678foo(); // 1var foo;function foo() &#123; console.log( 1 );&#125;foo = function() &#123; console.log( 2 );&#125;; 会输出 1 而不是 2 !这个代码片段会被引擎理解为如下形式:1234567function foo() &#123; console.log( 1 );&#125;foo(); // 1foo = function() &#123; console.log( 2 );&#125;; 注意，var foo 尽管出现在 function foo()… 的声明之前，但它是重复的声明(因此被忽略了)，因为函数声明会被提升到普通变量之前。注意: js会忽略前面已经声明的声明(不管是变量声明还是函数声明,只要其名称相同,则后续不会再进行重复声明).但是对该变量新的赋值,会覆盖之前的值.一句话概括:函数声明的优先级高于变量声明,会排在它前面. 4.4 小结 对于var a = 2 JavaScript引擎会将var a和 a = 2当作两个单独的声明，第一个是编译阶段的任务，而第二个则是执行阶段的任务。 论作用域中的声明出现在什么地方，都将在代码本身被执行前首先进行处理。 可以将这个过程形象地想象成所有的声明(变量和函数)都会被“移动”到各自作用域的最顶端，这个过程被称为提升。 声明本身会被提升，而包括函数表达式的赋值在内的赋值操作并不会提升(即赋值操作都不会提升)。 注意:，当普通的 var 声明和函数声明混合在一起的时候，并且声明相同时(var的变量名和函数名相同时,会引发js对重复声明的忽略)!一定要注意避免重复声明! 第五章 作用域闭包5.1 启示 JavaScript中闭包无处不在，你只需要能够识别并拥抱它。 闭包是基于词法作用域书写代码时所产生的自然结果，你甚至不需要为了利用它们而有意识地创建闭包。 5.2 实质问题 &amp;&amp; 5.3 现在我懂了因为这两小节理解透了其实发现书里也没讲什么,这里就进行合并,并补充拓展我自己的理解和总结.什么是闭包?(广义版)书中解释: 当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域之外执行。MDN的解释: 闭包是函数和声明该函数的词法环境的组合。我的解释(详细版): 必须包含两点: 1,有函数.由于函数自身的特性,它能访问所在的词法作用域.并能保存外部词法作用域的变量和函数到自己的函数作用域. 2,有该函数所在的词法环境.其实在JavaScript中任何函数都会处在一个词法环境中.不管是全局作用域还是函数作用域. 综上简单版就是:MDN的解释闭包是函数和声明该函数的词法环境的组合。还可以继续延伸成极简版:JavaScript中的函数就会形成闭包。Tips: 注意到上面对词法作用域和词法环境两词的分开使用了吗?1,里此时函数还没被执行,所以使用的是词法作用域即静态作用域.2,里,此时函数被执行,此时词法作用域就会变成词法环境(包含静态作用域与动态作用域).所以其实MDN的解释其实更准确一点, 我们日常使用时所说的闭包(狭义版,严格意义上的):为了便于对闭包作用域的观察和使用.我们实际使用时会将闭包的函数作用域暴露给当前词法作用域之外.也就是本书一直强调的闭包函数需要在它本身的词法作用域以外执行.作者认为符合这个条件才称得上是真正的闭包(也就是我们日常使用常说的’使用闭包’,并且使用任何回调函数其实也是闭包).所以狭义版就是:闭包是函数和声明该函数的词法环境的组合,并且将闭包的函数作用域暴露给当前词法作用域之外. 闭包暴露函数作用域的三种方式:下面部分是书中没有的,是自己实际使用时的总结,并且符合这三种形式之一的就是我们日常使用时所说的闭包(狭义版) 1,通过外部函数的参数进行暴露. 1234567891011function foo() &#123; var a = 2; function bar() &#123; baz(a) //通过外部函数的参数进行暴露 &#125; bar(); &#125;;function baz(val) &#123; console.log( val ); // 2 &#125;foo(); 2,通过外部作用域的变量进行暴露 12345678910var val;function foo() &#123; var a = 2; function bar() &#123; val=a //通过外部作用域的变量进行暴露 &#125; bar(); &#125;;foo();console.log(val) //2 3,通过return直接将整个函数进行暴露 123456789function foo() &#123; var a = 2; function bar() &#123; console.log(a) &#125; return bar //通过return直接将整个函数进行暴露&#125;;var val=foo();val() //2 关于闭包的内存泄露问题:首先必须声明一点:使用闭包并不一定会造成内存泄露,只有使用闭包不当才可能会造成内存泄露.(吐槽:面试很多新人时,张口就说闭包会造成内存泄露)为什么闭包可能会造成内存泄露呢?原因就是上面提到的,因为它一般会暴露自身的作用域给外部使用.如果使用不当,就可能导致该内存一直被占用,无法被JS的垃圾回收机制回收.就造成了内存泄露.注意: 即使闭包里面什么都没有,闭包仍然会隐式地引用它所在作用域里的所用变量. 正因为这个隐藏的特点,闭包经常会发生不易发现的内存泄漏问题.常见哪些情况使用闭包会造成内存泄露: 1,使用定时器未及时清除.因为计时器只有先停止才会被回收.所以决办法很简单,将定时器及时清除,并将造成内存的变量赋值为null(变成空指针) 2,相互循环引用.这是经常容易犯的错误,并且也不容易发现.举个栗子:12345678function foo() &#123; var a = &#123;&#125;; function bar() &#123; console.log(a); &#125;; a.fn = bar; return bar; &#125;; 这里创建了一个a 的对象，该对象被内部函数bar引用。然后，a创建了一个属性fn指向了bar，最后返回了innerFn()。这样就形成了bar和a的相互循环引用.可能有人说bar里不使用console.log(a)不就没有引用了吗就不会造成内存泄露了.NONONO,bar作为一个闭包,即使它内部什么都没有,foo中的所有变量都还是隐使地被 bar所引用。这个知识点是我前面忘记提到的,也是书中没有提到的.算了我现在加到前面去吧.所以即使bar内什么都没有还是造成了循环引用,那真正的解决办法就是,不要将a.fn = bar. 3,将闭包引用到全局变量上.因为全局变量是只有当页面被关闭的时候才会被回收. 4,在闭包中对DOM进行不当的引用.这个常见于老IE浏览器,现代浏览器已经长大了,已经学会了自己处理这种情况了.这里就不赘述了.想知道的可以自行问谷娘和度娘. 总而言之,解决办法就是使闭包的能正常引用,能被正常回收.如果实在不行,就是在使用完后,手动将变量赋值null,强行进行垃圾回收. 5.4 循环和闭包看如下例子:12345for (var i=1; i&lt;=5; i++) &#123; setTimeout( function timer() &#123; console.log( i ); &#125;, i*1000 );&#125; 我们期望的结果是分别输出数字 1~5，每秒一次，每次一个。但实际结果是,这段代码在运行时会以每秒一次的频率输出五次 6。(关于书里的解释,我觉得有点说复杂了,没说到点子上,下面是我的解释.)为什么会是这样的结果?timer毫无疑问是一个闭包,它是可以访问到外部的变量i.在进行for循环时,timer()会被重复执行5次,也就是它会 console.log( i )5次.(关键部分来了!)这5次i其实是同一个i.它是来自于外部作用域,即for里面声明的i.在词法作用域中变量i只可能对应一个唯一的值,即变量和它的值是一一对应的.不会变化的.那这个值到底是多少呢?这个值就是最终值! i的最终值就是6即for循环完后i的值.当引擎执行console.log( i )时,它会询问i所对应的作用域,问它i的值是多少.这个时候作用域进行RHS查询得到的结果就是最终值6. 为什么我们会以为分别输出1~5?因为在for循环中,我们错以为每一次循环时,函数所输出的i是根据循环动态变化的.即是1~5累加变化的.但实际上它所访问的i是同一个固定不变的值,即最终值6.可能你会有这样的疑惑,那我循环还有意义吗?i其实一开始就确定是6了.没有变化过!错!i变化过,它的确是从1逐步增加到6的.只是外部作用域的i值只可能是循环完后的最终值,并且函数timer()并没有保存每次i变化的值.它只是访问了外部作用域的i值即最终的值6. OK我们知道了出错的地方,就是我们没有把每次i的值保存在一个独立的作用域中.接下来,看下这个改进的例子结果是多少.1234567for (var i=1; i&lt;=5; i++) &#123; (function() &#123; setTimeout( function timer() &#123; console.log( i ); &#125;, i*1000 ); &#125;)();&#125; 它的最终值仍然是5个6.为什么?我们来分析下,上例中,它用了一个匿名函数包裹了定时器,并立即执行.在进行for循环时,会创造5个独立的函数作用域(由匿名函数创建的,因为它是闭包函数).但是这5个独立的函数作用域里的i也全都是对外部作用域的引用.即它们访问的都是i的最终值6.这并不是我们想要的,我们要的是5个独立的作用域,并且每个作用域都保存一个”当时”i的值. 解决办法:那我们这样改写.123456789for (var i=1; i&lt;=5; i++) &#123; (function () &#123; var j =i; setTimeout( function timer() &#123; console.log( j ); &#125;, j*1000 ); &#125;)();&#125;//这次终于结果是分别输出数字 1~5，每秒一次，每次一个。 这样改写后,匿名函数每次都通过j保存了每次i值,这样i值就通过j保存在了独立的作用域中.注意此时保存的i值是’当时’的值,并不是循环完后的最终值.这样循环完后,实际上就创建了5个独立的作用域,每个作用域都保存了一个’当时’i的值(通过j).当引擎执行console.log( j )询问其对应的独立作用域时,得到的值就是’当时’保存的值,再也不是6了.我们还可以进一步简写为这样:12345678for (var i=1; i&lt;=5; i++) &#123; (function(j) &#123; setTimeout( function timer() &#123; console.log( j ); &#125;, j*1000 ); &#125;)(i);&#125;//结果是分别输出数字 1~5，每秒一次，每次一个。 利用块作用域进行解决:在es6中,我们不仅可以使用函数来创建一个独立的作用域,我们还可以使用let声明来创建一个独立的块作用域(在{}内).所以我们还可以这样改写:123456for (let i=1; i&lt;=5; i++) &#123; setTimeout( function timer() &#123; console.log( i ); &#125;, i*1000 );&#125;//结果是分别输出数字 1~5，每秒一次，每次一个。 这样改写,在每次循环时,let都会对i进行声明.并通过循环自带的{}创建一个独立的块作用域.并且let声明的i,保存了’当时’i的值在当前块作用域里.因此当引擎执行console.log( i )时,它会询问对应的块作用域上i的值,得到的结果就是’当时’保存的值. 延伸:实际上块作用域可以称得上一个’伪’闭包(之所以是伪,是因为闭包规定了只能是函数).因为它几乎拥有闭包的所有特性.它也可以创建一个独立的作用域,同样外部作用域不能访问块作用域的变量.但块作用域可以访问外部作用域.举个栗子:123456789function foo() &#123; var a = 2; &#123; //通过&#123;&#125; 显示表示块作用域 let b = a; console.log('块作用域内',b) //2 &#125; console.log('块作用域外',b) //b is not defined&#125;foo() 说了相同点,说说不同点:1,保存变量到块作用域,必须通过let声明.2,块作用域不能和函数一样有名称(函数名)很多不方便使用闭包或者比较麻烦的时候,是可以考虑通过块作用域进行解决. 总结一下一般什么时候考虑使用闭包:这部分也是自己工作使用的总结,如果有补充或者不对的地方,欢迎留言指正. 1,需要创建一个独立的作用域并隐藏一些变量或函数,不被外部使用;或者想保存一些外部作用域的变量或函数到这个独立作用域. 2,只想暴露一部分自身作用域的变量或函数给外部使用. 5.5 模块首先看下面的例子:123456789101112131415161718function CoolModule() &#123; var something = "cool"; var another = [1, 2, 3]; function doSomething() &#123; console.log( something ); &#125; function doAnother() &#123; console.log( another.join( " ! " ) ); &#125; return &#123; doSomething: doSomething, doAnother: doAnother &#125;; &#125;var foo = CoolModule(); foo.doSomething(); // coolfoo.doAnother(); // 1 ! 2 ! 3 首先我们对上面这段代码进成分行分析:私有数据变量:something, another内部函数:doSomething, doAnother直接说结论,上面这个例子就是模块模式.它return返回的这个对象也就是模块也被称为公共API(至少书中是这样称呼的).CoolModule()就是模块构造器或者叫模块函数.注意: 这里的模块和我们所说的模块化开发不是完全一样的! 模块不一定非要是标准对象,也可以是一个函数,函数本质上也是对象,函数也可以有自己的属性. 书中有这样一句话CoolModule() 只是一个函数，必须要通过调用它来创建一个模块实例。如果不执行外部函数，内部作用域和闭包都无法被创建。我觉得这句话有必要延伸说一下.函数调用一次就会创建一个该函数的作用域(不调用就不会创建),包括创建它里面的变量和函数. 模块模式:模块模式需要具备以下2个条件:(这里结合上面的例子,对书中的定义进行说明方便理解) 1, 必须有外部的封闭函数(即CoolModule)，该函数必须至少被调用一次(每次调用都会创建一个新的模块实例–&gt;模块实例指的就是函数return返回的对象)。 2, 封闭函数(即CoolModule)必须返回至少一个内部函数(即doSomething, doAnother)，这样内部函数才能在私有作用域中形成闭包，并且可以访问或者修改私有的状态(即something, another)。 模块:表面上看由模块函数(例子中的CoolModule)所返回的对象就是模块.但模块还必须还包含模块函数的内部函数(即闭包函数).只有包含了才能真正称得上是模块.才强调一次这里的模块与模块化里的模块是有区别的,也不是nodejs里的模块. 模块函数:模块函数也就是模块构造器,例子中的CoolModule().一般它有两个常见用法. 通过接受参数,对输出的模块进行修改. 通过添加模块里添加相关的内部函数,实现对输出模块数据的增删改查.(书中用命名将要作为公共API返回的对象.我觉得命名应该是用错了,应该是修改即增删改查更好) 5.5.1 现代的模块机制大多数模块依赖加载器 / 管理器本质上都是将这种模块定义封装进一个友好的 API。下面就介绍一个简单的模块管理器实现例子(对书中的例子进行逐行解读):1234567891011121314151617181920212223242526272829303132//首先实例化我们的模块管理器,取名myModulesvar MyModules=(function Manager() &#123; //作为我们的模块池,保存所有定义的模块 var modules=&#123;&#125;; /** *使用类似AMD的方式定义新模块，接收3个参数 *name:模块名 *deps:数组形式表示所依赖的其他模块 *impl:模块功能的实现 **/ function define(name,deps,impl) &#123; //遍历依赖模块数组的每一项，从程序池中取出对应的模块,并赋值. //循环完后,deps由保存模块名的数组变成了保存对应模块的数组. for (var i=0;i&lt;deps.length;i++) &#123; deps[i]=modules[deps[i]]; &#125; //将新模块存储进模块池，并通过apply注入它所依赖的模块(即遍历后的deps,实际上就是用deps作为impl的入参) modules[name]=impl.apply(impl,deps); &#125; //从模块池中取出对应模块 function get (name) &#123; return modules[name]; &#125; //暴露定义模块和获取模块的两个api return &#123; define: define, get: get &#125;&#125;)() 说明: 后面书中说了这么一句为了模块的定义引入了包装函数(可以传入任何依赖),这里包装函数指的是Manger(),同样也是我们上节提到的模块函数.首先说明下什么是包装函数.例如函数A当中还有一个函数B.当我们想要调用函数B的时候,则需要先调用函数A.那么函数A就叫做函数B的包装函数.也就是说我们想调用某个模块时,需要先调用它的包装函数即这里的Manger().接着是后面那句并且将返回值，也就是模块的 API，储存在一个根据名字来管理的模块列表中。注意这里的返回值是指impl的返回值. 接着看通过管理器来定义和使用模块 123456789101112131415161718192021222324252627282930313233MyModules.define('bar',[],function () &#123; function hello (who) &#123; return "Let me introduce: " + who; &#125; //返回公共API 即提供一个hello的接口 return &#123; hello:hello &#125;;&#125;);MyModules.define('foo',['bar'],function (bar) &#123; var hungry = "hippo"; functin awesome () &#123; //这里的bar为返回模块bar返回的公共API console.log( bar.hello( hungry ).toUpperCase() ); &#125; //返回公共API 即提供一个awesome的接口 return &#123; awesome:awesome &#125;&#125;)var bar=MyModules.get('bar');//通过管理器获取模块'bar'var foo=MyModules.get('foo');//通过管理器获取模块'foo'console.log(//调用模块bar的hello接口 bar.hello( "hippo" ) ); // Let me introduce: hippo //调用模块foo的awesome接口foo.awesome(); // LET ME INTRODUCE: HIPPO 这节的主要内容还是了解现在是如何对模块进行一个规范处理.主要是两部分内容,一个是通过名称和依赖合理定义模块并储存.另一个则是通过名称对存储的模块的调用.其实还可以再增加一个删除模块的方法. 5.5.2 未来的模块机制ok,这节说的模块,就是我们常说的模块化开发.并且主要提到的就是ES6里常用的import.没什么好说的. 5.6 小结吐槽: 同一个函数概念在5.5这一个小节里,居然换着花样蹦出了三个名字!一会叫模块构造器!一会叫模块函数!以及最后的包装函数!每变化一次,都得想一遍它指的是啥!真的是无力吐槽了!!!! 闭包:当函数可以记住并访问所在的词法作用域，并且函数是在当前词法作用域之外执行，这时 就产生了闭包。 模块有两个主要特征: (1)为创建内部作用域而调用了一个包装函数(模块构造器的实例化,不想对频繁换名字吐槽了); (2)包装函数的返回值(也就是模块)必须至少包括一个对内部函数的引用，这样就会创建涵盖整个包装函数内部作用域的闭包。 第二部分第一章 关于this1.1 为什么要用this因为this 提供了一种更优雅的方式来隐式“传递”一个对象(即上下文对象)引用，因此可以将 API 设计得更加简洁并且易于复用。 1.2 误解下面两种常见的对于 this 的解释都是错误的(看看就好,就不过多解读了,以免增加了对错误的印象)。 1.2.1 指向自身人们很容易把 this 理解成指向函数自身. 具名函数，可以在它内部可以使用函数名来引用自身进行递归,添加属性等。(这个知识点其实在第三章提过,既然这里又提了一遍,我也再说一遍.)例如:123function foo() &#123; foo.count = 4; // foo 指向它自身&#125; 匿名函数如果想要调用自身则,需要使用arguments.callee不过这个属性在ES5严格模式下已经禁止了,也不建议使用.详情可以查看MDN的说明. 1.2.2 它的作用域切记: this 在任何情况下都不指向函数的词法作用域。你不能使用 this 来引用一个词法作用域内部的东西。 这部分只需记住这一段话就行. 终极疑问: JavaScript里的作用域到底是对象吗?这小节最令我在意的是里面这句话”在 JavaScript 内部，作用域确实和对象类似，可见的标识符都是它的属性。但是作用域“对象”无法通过 JavaScript代码访问，它存在于JavaScript 引擎内部。”它让我想起了最开始学JS的一个疑问,JavaScript里的作用域到底是对象吗.虽然”在JS里万物皆对象”.但是作用域给人的感觉却不像是一个对象.更像是一个范围,由函数的{}围城的范围,限制了其中变量的访问.但直觉告诉我它和对象还是应该有点联系的.直到读到书中的这段话,更加印证了我的感觉.在JavaScript里,作用域其实是一个比较特殊的对象,作用域里所有可见的标识符都是它的属性.只是作用域对象并不能通过JavaScript代码被我们访问,它只存在于JavaScript引擎内部.所以作用域作为一个”对象”是经常被我们忽略. 1.3 this到底是什么this 是在运行时(runtime)进行绑定的，并不是在编写时绑定，它的上下文(对象)取决于函数调用时的各种条件。this 的绑定和函数声明的位置没有任何关系，只取决于函数的调用方式。 当一个函数被调用时，会创建一个活动记录(有时候也称为执行上下文)。这个记录会包含函数在哪里被调用(调用栈)、函数的调用方法、传入的参数等信息。this 就是记录的其中一个属性，会在函数执行的过程中用到。(PS:所以this并不等价于执行上下文) 1.4 小结 学习 this 的第一步是明白 this 既不指向函数自身也不指向函数的词法作用域 this 实际上是在函数被调用时发生的绑定，它指向什么完全取决于函数在哪里被调用(关于this你必须记住的话)。 第二章 this全面解析2.1 调用位置通过上节我们知道,this的绑定与函数的调用位置有关.那调用位置是什么.调用位置就是函数在代码中被调用的位置(而不是声明的位置)。 要寻找调用位置,最重要的是要分析调用栈(就是为了到达当前执行位置所调用的所有函数)。我们关心的调用位置就在当前正在执行的函数的前一个调用中。PS:调用栈其实是一个解释起来有点复杂的概念.这里我就不过多解释,这里推荐一篇文章,解释得不错. 这节书里的例子解释得不错,这里就不复制代码了.其实分析调用栈只是为了在运行时找到我们关心的函数到底在哪里和被谁调用了. 但是实际别写代码时,其实并不会分析得这么清楚的,我们还是只需记住this的指向就是我们调用该函数的上下文对象.意思就是我们在哪里调用该函数,this就指向哪里.并且查看调用栈还可以通过浏览器的开发者工具,只需在疑惑的代码上一行加上debugger即可.浏览器在调试模式时,我们就可以在调用列表里查看调用栈.我们一般也仅在查找bug时,会使用该方法. 2.2 绑定规则在找到调用位置后,则需要判定代码属于下面四种绑定规则中的哪一种.然后才能对this进行绑定.注意: this绑定的是上下文对象,并不是函数自身也不是函数的词法作用域 2.2.1 默认绑定什么是独立函数调用:对函数直接使用而不带任何修饰的函数引用进行调用.简单点一个函数直接是func()这样调用,前面什么都没有.不同于通过对象属性调用例如obj.func(),也没有通过new关键字new Function();也没有通过apply,bind,call强制改变this指向.默认绑定: 当被用作独立函数调用时（不论这个函数在哪被调用,不管全局还是其他函数内），this默认指向到window；注意: 如果使用严格模式(strict mode)，那么全局对象将无法使用默认绑定，因此 this 会绑定到 undefined. 2.2.2 隐式绑定隐式绑定: 函数被某个对象拥有或者包含.也就是函数被作为对象的属性所引用.例如obj.func().此时this会绑定到该对象上.隐式丢失: 不管是通过函数别名或是将函数作为入参造成的隐式丢失.只需找到它真正的调用位置,并且函数前没有任何修饰也没有显式绑定(下节会讲到)(非严格模式下).那么this则会进行默认绑定,指向window.注意: 实际工作中,大部分this使用错误都是由对隐式丢失的不理解造成的.记住函数调用前没有任何修饰和显式绑定(其实就是call、apply、bind),this就指向window 2.2.3 显式绑定在分析隐式绑定时，我们必须在一个对象内部包含一个指向函数的属性，并通过这个属性间接引用函数，从而把 this 间接(隐式)绑定到这个对象上。如果我们不想在对象内部包含函数引用，而想在某个对象上强制调用函数，此时则需要显式绑定.显式绑定: 可以直接指定 this 的绑定对象，被称之为显式绑定。基本上就是我们常使用的call、apply、bind方法都是显式绑定.(如果这三个方法不能熟练使用的,建议找度娘或者谷娘学习后,再看这节.)注意:如果你传入了一个原始值(字符串类型、布尔类型或者数字类型)来当作 this 的绑定对 象，这个原始值会被转换成它的对象形式(也就是new String(..)、new Boolean(..)或者 new Number(..))。这通常被称为“装箱”。 硬绑定: 使用call、apply、bind方法强制显式地将this进行绑定,称之为硬绑定。硬绑定的典型应用场景就是创建一个包裹函数(其实就是常说的封装函数)，传入所有的参数并返回接收到的所有值.在封装函数中,我们常使用apply.一方面是因为它可以手动绑定this,更重要的是因为可以用apply的第二个参数,方便地注入所有传入的参数.例如之前提到的modules[name]=impl.apply(impl,deps).因为我们不知道传入的参数有多少个,但我们可以方便地使用一个deps将其全部注入.另一个常用的是foo.apply( null,argue)当我们将apply的第一个参数设置为null时,此时this就会默认绑定到window.切记使用这种用法时确保函数foo内没有使用this. 否则很可能会造成全局污染.如果是第三方库的函数就建议不要使用了,因为你不知道别人的函数是否使用了this(关于这部分内容,下节会继续提到).还有一种常用就是foo.call( this).这样foo里的this都会指向当前调用的上下文环境. API调用的“上下文”: 第三方库的许多函数，以及 JavaScript 语言和宿主环境中许多新的内置函数，都提供了一个可选的参数，通常被称为“上下文”(context)，其作用和 bind(..) 一样，确保你的回调函数使用指定的 this。 2.2.4 new绑定JavaScript 中 new 的机制实际上和面向类的语言完全不同。在 JavaScript 中，构造函数只是一些 使用 new 操作符时被调用的函数。它们并不会属于某个类，也不会实例化一个类。实际上， 它们甚至都不能说是一种特殊的函数类型，它们只是被 new 操作符调用的普通函数而已。实际上并不存在所谓的“构造函数”，只有对于函数的“构造调用”。 使用 new 来调用函数，或者说发生构造函数调用时，会自动执行下面的操作。 1,创建(或者说构造)一个全新的对象。 2,这个新对象会被执行[[原型]]连接。 3,这个新对象会绑定到函数调用的this。 4,如果函数没有返回其他对象，那么new表达式中的函数调用会自动返回这个新对象。 示例:12345function foo(a) &#123; this.a = a;&#125;var bar = new foo(2); console.log( bar.a ); // 2 使用 new 来调用 foo(..) 时，我们会构造一个新对象并把它绑定到 foo(..) 调用中的 this 上。说明:对于上面这句话进行解释下,如果在一个函数前面带上 new 关键字来调用， 那么背地里将会创建一个连接到该函数的 prototype 的新对象，this就指向这个新对象； 2.3 优先级直接上结论:new绑定=显示绑定&gt;隐式绑定&gt;默认绑定说明: new绑定与显示绑定是不能直接进行测试比较,但通过分析发现new绑定内部其实是使用了硬绑定(显示绑定的一种),所以new绑定和显示绑定优先级应该差不多.但话说回来,一般实际使用时,不会这种复杂的交错绑定.所以只需记住下面的判定即可. 判断this:现在我们可以根据优先级来判断函数在某个调用位置应用的是哪条规则。可以按照下面的顺序来进行判断: 1,函数是否在new中调用(new绑定)?如果是的话this绑定的是新创建的对象。 var bar = new foo() 2,函数是否通过call、apply(显式绑定)或者硬绑定调用?如果是的话，this绑定的是 指定的对象。var bar = foo.call(obj2) 3,函数是否在某个上下文对象中调用(隐式绑定)?如果是的话，this 绑定的是那个上 下文对象。var bar = obj1.foo() 4,如果都不是的话，使用默认绑定。如果在严格模式下，就绑定到undefined，否则绑定到 全局对象。var bar = foo()就是这样。对于正常的函数调用来说，理解了这些知识你就可以明白 this 的绑定原理了。 2.4 绑定例外2.4.1 被忽略的this如果你把 null 或者 undefined 作为 this 的绑定对象传入 call、apply 或者 bind，这些值在调用时会被忽略，实际应用的是默认绑定规则,this会绑定到window上.使用情景:一种非常常见的做法是使用 apply(..) 来“展开”一个数组(也可以用来方便地参数注入)，并当作参数传入一个函数。类似地，bind(..) 可以对参数进行柯里化(预先设置一些参数).通过自带bind方法实现柯里化是很方便的,比自己写要简化好多. 注意: 在 ES6 中，可以用 … 操作符代替 apply(..) 来“展 开”数组，foo(…[1,2]) 和 foo(1,2)是一样的，这样可以避免不必要的 this 绑定。可惜，在 ES6 中没有柯里化的相关语法，因此还是需要使用 bind(..)。 当使用null或者undefined进行绑定时,要确保该函数内没有使用this,否则此时很容易对全局变量造成破坏!尤其是使用第三方库的方法! 更安全的this如果函数内使用了this,直接使用null则可能会对全局造成破坏.因此我们可以通过创建一个“DMZ”(demilitarized zone，非军事区)对象——它就是一个空的非委托的对象(委托在第 5 章和第 6 章介绍)。让this绑定到这个”DMZ上.这样就不会对全局造成破坏.怎么创建DMZ呢.就是通过Object.create(null) 创建一个空对象.这种方法和 {} 很像，但是并不会创建 Object.prototype 这个委托，所以它比 {}“更空”更加安全. PS:实际使用一般不会遇到这种情况(也可能是我太菜,没遇到),如果函数内有this,那肯定是有需要调用的变量或函数,直接把它绑定到一个空对象上.那什么都取不到,还有什么意义?所以函数没有this就传入null.如果有this就把它绑定到真正需要它的对象上,而不是一个空对象上.这些是我自己的见解,如果有不妥的,欢迎留言指正. 2.4.2 间接引用12345678function foo() &#123; console.log( this.a );&#125;var a = 2;var o = &#123; a: 3, foo: foo &#125;; var p = &#123; a: 4 &#125;;o.foo(); // 3(p.foo = o.foo)(); // 2 其实就是foo() 此时this默认绑定到window 例子中的间接引用其实是对函数的理解不深造成的.其实(p.foo = o.foo)()就是(foo)(),这样就是全局调用foo()所以this默认就绑定到了window上.注意:对于默认绑定来说，决定 this 绑定对象的并不是调用位置是否处于严格模式，而是 函数体是否处于严格模式。如果函数体处于严格模式，this 会被绑定到 undefined，否则 this 会被绑定到全局对象。(对于这段话其实在2.2.1节就应该说了!) 2.4.3 软绑定硬绑定会大大降低函数的灵活性，使用硬绑定之后就无法使用隐式绑定或者显式绑定来修改 this。这时候则需要使用软绑定.Tips: 这里给的软绑定方法还是挺好的.但是建议还是在自己的代码里使用,并注释清除.以免别人使用,对this错误的判断. 2.5 this词法 ES6 中介绍了一种无法使用上面四条规则的特殊函数类型:箭头函数。 箭头函数不使用 this 的四种标准规则，而是根据外层(函数或者全局)作用域来决定 this。(而传统的this与函数作用域没有任何关系,它只与调用位置的上下文对象有关.这点在本章开头就已经反复强调了.) 重要: 箭头函数最常用于回调函数中，例如事件处理器或者定时器. 箭头函数可以像 bind(..) 一样确保函数的 this 被绑定到指定对象 箭头函数用更常见的词法作用域取代了传统的 this 机制。 注意: 这种情况:1234567891011function module() &#123; return this.x;&#125;var foo = &#123; x: 99, bar:module.bind(this) //此时bind绑定的this为window. &#125;var x="window"console.log(foo.bar())//window 在 ES6 之前我们就已经在使用一种几乎和箭头函数完全一样的模式:12345678910function foo() &#123;var self = this; // lexical capture of this setTimeout( function()&#123; console.log( self.a ); &#125;, 100 ); &#125;var obj = &#123; a: 2&#125;;foo.call( obj ); // 2 虽然 self = this 和箭头函数看起来都可以取代 bind(..)，但是从本质上来说，它们想替代的是 this 机制。(的确是这样,我一般会用me替代self.因为少两个单词=.=) 关于this的编码规范建议: 只使用词法作用域并完全抛弃错误this风格的代码; 完全采用 this 风格，在必要时使用 bind(..)，尽量避免使用 self = this 和箭头函数。 在自己实际工作中,其实是两种混用的,绝大部分情况下都会使用词法作用域风格.因为有时候你真的很难做到完全统一.我现在的习惯是,在写任何函数时,开头第一个就是var me =this;这样在看到函数第一眼,就知道:哦,这个函数是用词法作用域风格的.尤其函数内涉及到回调.这样就避免了写着写着发现this绑定到其他地方去了,一个函数里面this不统一的情况. 2.6 小结(这里总结得很好,我就全部copy了)如果要判断一个运行中函数的 this 绑定，就需要找到这个函数的直接调用位置。找到之后就可以顺序应用下面这四条规则来判断 this 的绑定对象。 由new调用?绑定到新创建的对象。 由call或者apply(或者bind)调用?绑定到指定的对象。 由上下文对象调用?绑定到那个上下文对象。 默认:在严格模式下绑定到undefined，否则绑定到全局对象。 一定要注意，有些调用可能在无意中使用默认绑定规则。如果想“更安全”地忽略 this 绑定，你可以使用一个 DMZ 对象，比如 ø = Object.create(null)，以保护全局对象。 ES6 中的箭头函数并不会使用四条标准的绑定规则，而是根据当前的词法作用域来决定 this，具体来说，箭头函数会继承外层函数调用的 this 绑定(无论 this 绑定到什么)。这其实和 ES6 之前代码中的 self = this 机制一样。 特别注意: 其中最需要注意的就是当你使用jquery或vue时,此时this是被动态绑定了的.大多数 jQuery 方法将 this 设置为已选择的 dom 元素。使用 Vue.js时，则方法和计算函数通常将 this 设置为 Vue 组件实例。vue文档中所有的生命周期钩子自动绑定 this 上下文到实例中，因此你可以访问数据，对属性和方法进行运算。这意味着你不能使用箭头函数来定义一个生命周期方法 (例如 created: () =&gt; this.fetchTodos())。这是因为箭头函数绑定了父上下文，因此 this 与你期待的 Vue 实例不同，this.fetchTodos 的行为未定义。 也包括使用第三方ajax时,例如axios.解决方法也很简单,要么使用传统的function或者使用let _this=this进行接管.其实当你使用vue时,你默认的思想就是this指的就是vue实例.所以除了钩子函数和axios里会有点影响外,其余还好. PS 这里再补充说明上下文(对象)与函数作用域的区别于联系: 上下文： 可以理解为一个对象，所有的变量都储存在里面.上下文环境是在函数被调用并被引擎执行时创建的.如果你没调用,那么就没有上下文. 作用域： 除了全局作用域，只有函数和ES6新增的let,const才能创建作用域.创建一个函数就创建了一个作用域，无论你调用不调用，函数只要创建了，它就有独立的作用域.作用域控制着被调用函数中的变量访问. 两者: 作用域是基于函数的，而上下文是基于对象的。作用域涉及到所被调用函数中的变量访问，并且不同的调用场景是不一样的。上下文始终是this关键字有关， 它控制着this的引用。一个作用域下可能包含多个上下文。有可能从来没有过上下文（函数没有被调用）；有可能有过，现在函数被调用完毕后，上下文环境被销毁了(垃圾回收)；有可能同时存在一个或多个（闭包）。 第三章 对象3.1 语法对象可以通过两种形式定义:声明(文字)形式(就是常说的对象字面量)和构造形式。 声明形式(对象字面量):1234 var myObj = &#123; key: value // ... &#125;; 构造形式:12var myObj = new Object(); myObj.key = value; 构造形式和文字形式生成的对象是一样的。唯一的区别是，在文字声明中你可以添加多个 键 / 值对，但是在构造形式中你必须逐个添加属性。PS:其实我们绝大部分情况下都是使用对象字面量形式创建对象. 3.2 类型在JavaScript中一共有6中主要类型(术语是”语言类型”) string number boolean null undefined object 简单数据类型:其中string、boolean、number、null 和 undefined属于简单基本类型,并不属于对象.null 有时会被当作一种对象类型，但是这其实只是语言本身的一个 bug，即对 null 执行typeof null 时会返回字符串 “object”。实际上，null 本身是基本类型。PS: 原因是这样的，不同的对象在底层都表示为二进制，在 JavaScript 中二进制前三位都为 0 的话会被判 断为 object 类型，null 的二进制表示是全 0，自然前三位也是 0，所以执行 typeof 时会返回“object”。 对象:对象除了我们自己手动创建的,JavaScript其实内置了很多对象,也可以说是对象的一个子类型.内置对象: String Number Boolean Object Function Array Date RegExp Error 在 JavaScript 中，这些内置对象实际上只是一些内置函数。这些内置函数可以当作构造函数(由 new 产生的函数调用——参见第 2 章)来使用.几点说明: 函数就是对象的一个子类型(从技术角度来说就是“可调用的对象”)。JavaScript 中的函数是“一等公民”，因为它们本质上和普通的对象一样(只是可以调用)，所以可以像操作其他对象一样操作函数(比如当作另一个函数的参数)。 通过字面量形式创建字符串,数字,布尔时,引擎会自动把字面量转换成 String 对象,Number对象,Boolean对象，所以它们是可以访对应对象内置的问属性和方法。 null 和 undefined 没有对应的构造形式，它们只有文字形式。相反，Date 只有构造，没有文字形式。 对于 Object、Array、Function 和 RegExp(正则表达式)来说，无论使用文字形式还是构造形式，它们都是对象，不是字面量(这是肯定的,因为不管哪种形式一创建出来就是对象类型,不可能是其他类型,实际上是不存在字面量这一说的)。但是使用构造形式可以提供一些额外选项(内置)。 Error 对象很少在代码中显式创建，一般是在抛出异常时被自动创建。也可以使用 new Error(..) 这种构造形式来创建，不过一般来说用不着。 3.3 内容对象属性:由一些存储在特定命名位置的(任意类型的)值.属性名:存储在对象容器内部的属性的名称.属性值并不会存在对象内.而是通过属性名(就像指针,从技术角度来说就是引用)来指向这些值真正的存储位置(就像房门号一样).属性名的两种形式: 使用.操作符.也是我们最常用的形式.它通常被称为”属性访问”. . 操作符会要求属性名满足标识符的命名规范. 使用[&quot;..&quot;]语法进行访问.这个通常被称为”键访问”.[&quot;..&quot;]语法可以接受任意UTF-8/Unicode 字符串作为属性名。并且[&quot;..&quot;]语法使用字符串来访问属性,如果你的属性名是一个变量,则可以使用书中的例子myObject[idx]形式进行访问.这也是最常使用”键访问”的情况.但如果idx是属性名则还是需写成myObject[&quot;idx&quot;]字符串形式. 注意: 在对象中，属性名永远都是字符串。如果你使用 string(字面量)以外的其他值作为属性 名，那它首先会被转换为一个字符串。即使是数字也不例外，虽然在数组下标中使用的的 确是数字，但是在对象属性名中数字会被转换成字符串 . 补充: 这里我在书中的例子基础上进行了修改,得到这个例子:123456789var myObject = &#123; a:2, idx:111&#125;;var idx="a";console.log( myObject[idx] ); //2console.log( myObject["idx"] ); //111console.log( myObject[this.idx] ); // 2 此时this是指向window.[]里的this同样符合上一章所讲的规则//结果是否和你所想得一样呢? 3.3.1 可计算属性名ES6 增加了可计算属性名，可以在文字形式中使用 [] 包裹一个表达式来当作属性名:12345678var prefix = "foo";var myObject = &#123; [prefix + "bar"]:"hello", [prefix + "baz"]: "world"&#125;;myObject["foobar"]; // hellomyObject["foobaz"]; // world 3.3.2 属性与方法 我们经常把对象内部引用的函数称为“方法”(的确如此). 实际上函数并不属于该对象,它不过是对函数的引用罢了.对象属性访问返回的函数和其他函数没有任何区别(除了可能发生的隐式绑定this到该对象)。 即使你在对象的文字形式中声明一个函数表达式，这个函数也不会“属于”这个对象—— 它们只是对于相同函数对象的多个引用。 3.3.3 数组 数组支持[]形式访问储存的值,其中[]内的值默认形式为数值下标(为从0开始的整数,也就是常说的索引).例如myArray[0] 数组也是对象，所以虽然每个下标都是整数，你仍然可以给数组添加属性.例如myArray.baz = &quot;baz&quot;.注意:添加新属性后,虽然可以访问,但数组的 length 值不会改变. 数组可以通过myArray[1]=11;myArray[&quot;2&quot;]=22;这种形式对数组内容进行修改,添加. 虽然数组也可以和对象一样通过键/值 对 形式来使用.但JS已经对数组的行为和用途进行了优化.所以还是建议使用默认的下标/值 对 形式来使用. 3.3.4 复制对象 复制分为浅拷贝和深拷贝.浅拷贝会对对象中的基本数据类型进行复制(在内存中开辟新的区域),对于对象则是继续引用.而不是重新创建一个”一样的”对象.深拷贝则是对其中的所有内(容包括对象)进行深层次的复制. 一般情况下我们可以通过JSON来复制对象.var newObj = JSON.parse( JSON.stringify( someObj ) );.但需要指出的是这种方法对于包含function函数或者Date类型的对象则不管用! ES6 定义了 Object.assign(..) 方法来实现浅复制。具体用法在这就不赘述了. 3.3.5 属性描述符从 ES5 开始，所有的属性都具备了属性描述符。 查看属性描述符: 可以使用Object.getOwnPropertyDescriptor( myObject, “a” );方法查看myObject对象里属性a的属性描述符. 配置属性描述符: 可以使用Object.defineProperty(..)方法对属性的属性描述符就像配置.举个例子:123456789 var myObject = &#123;&#125;;Object.defineProperty( myObject, "a", &#123; value: 2, writable: true, configurable: true, enumerable: true &#125; );myObject.a; // 2//该方法可以配置四个属性描述符 注意: 书中关于属性描述符也被称为“数据描述符”其实是不够准确的.对象里目前存在的属性描述符有两种主要形式：数据描述符和存取描述符。数据描述符是一个具有值的属性，该值可能是可写的，也可能不是可写的。存取描述符是由getter和setter函数对描述的属性。描述符必须是这两种形式之一；不能同时是两者。(getter和setter是后面马上要讲到的两个描述符)它们的关系如下:(详情可以查看MDN的解释) configurable enumerable value writable get set 数据描述符 Yes Yes Yes Yes No No 存取描述符 Yes Yes No No Yes Yes 如果一个描述符不具有value,writable,get 和 set 任意一个关键字，那么它将被认为是一个数据描述符。如果一个描述符同时有(value或writable)和(get或set)关键字，将会产生一个异常。 value就是该属性对应的值。默认为 undefined。下面分别介绍剩下的三个属性描述符键值: 1. Writable 决定是否可以修改属性的值。当被设置为false后,再对属性值进行修改,则会静默失败(silently failed,修改不成功,也不报错)了。如果在严格模式下，则会报出TypeError错误. 2. Configurable 决定属性描述符是否可配置.如果为true,就可以使用 defineProperty(..) 方法来修改属性描述符.注意:不管是不是处于严格模式，修改一个不可配置的属性描述符都会出错。并且把 configurable 修改成 false 是单向操作，无法撤销! 但是有个例外即便属性是 configurable:false，我们还是可以 把 writable 的状态由 true 改为 false，但是无法由 false 改为 true。除了无法修改，configurable:false 还会禁止删除这个属性. 3. Enumerable 决定该属性是否会出现在对象的属性枚举中.比如说 for..in 循环。如果把 enumerable 设置成 false，这个属性就不会出现在枚举中，虽然仍然可以正常访问它。相对地，设置成 true 就会让它出现在枚举中。 3.3.6 不变性除了上面提到的Object.defineProperty(..),ES5还可以通过很多种方法来实现属性或者对象的不可变.注意: 这些所有方法都是只能浅不变,如果目标对象引用了其他对象(数组、对象、函数，等)，其他对象的内容不受影响，仍然是可变的.类似于浅拷贝. 说明: 在 JavaScript 程序中很少需要深不可变性。 有些特殊情况可能需要这样做，但是根据通用的设计模式，如果你发现需要密封或者冻结所有的对象，那你或许应当退一步，重新思考一下程序的设计，让它能更好地应对对象值的改变。 方法: 1. 对象常量(不可改) 结合 writable:false 和 configurable:false 就可以创建一个真正的常量属性(不可修改、重定义或者删除) 2. 禁止扩展(不可增) 使用 Object.prevent Extensions(myObject),可以禁止一个对象添加新属性并且保留已有属性.在非严格模式下，创建属性 b 会静默失败。在严格模式下，将会抛出 TypeError 错误。 3. 密封(不可配置,但可修改) 使用Object.seal(..) 会创建一个“密封”的对象，这个方法实际上会在一个现有对象上调用Object.preventExtensions(..) 并把所有现有属性标记为 configurable:false。密封之后不仅不能添加新属性，也不能重新配置或者删除任何现有属性(虽然可以修改属性的值)。 4. 冻结(不可配置,也不可修改) Object.freeze(..) 会创建一个冻结对象，这个方法实际上会在一个现有对象上调用 Object.seal(..) 并把所有“数据访问”属性标记为 writable:false，这样就无法修改它们的值。这个方法是你可以应用在对象上的级别最高的不可变性，它会禁止对于对象本身及其任意直接属性的修改(不过就像我们之前说过的，这个对象引用的其他对象是不受影响的)。 注意: 你可以“深度冻结”一个对象(连引用的对象也冻结)，具体方法为，首先在这个对象上调用 Object.freeze(..)， 然后遍历它引用的所有对象并在这些对象上调用 Object.freeze(..)。但是一定要谨慎!因为你引用的对象可能会在其他地发也被引用. 说明: 在 JavaScript 程序中很少需要深不可变性。有些特殊情况可能需要这样做， 但是根据通用的设计模式，如果你发现需要密封或者冻结所有的对象，那你或许应当退一步，重新思考一下程序的设计，让它能更好地应对对象值的改变。 3.3.7 [[Get]]1234var myObject = &#123; a: 2&#125;;myObject.a; // 2 myObject.a是怎么取到值2的?myObject.a 通过对象默认内置的[[Get]] 操作(有点像函数调用:[Get]).首先它会在对象中查找是否有名称相同的属性， 如果找到就会返回这个属性的值。如果没有找到名称相同的属性，按照 [[Get]] 算法的定义会执行另外一种非常重要的行为。其实就是遍历可能存在的 [[Prototype]] 链，也就是在原型链上寻找该属性。如果仍然都没有找到名称相同的属性，那 [[Get]] 操作会返回值 undefined. 注意: 如果你引用了一个当前词法作用域中不存在的变量，并不会像对象属性一样返回 undefined，而是会抛出一个 ReferenceError 异常. 3.3.8 [[Put]]既然有可以获取属性值的 [[Get]] 操作，就一定有对应的 [[Put]] 来设置或者创建属性. [[Put]] 被触发时的操作分为两个情况:1. 对象中已经存在这个属性 2. 对象中不存在这个属性. 如果对象中已经存在这个属性,[[Put]] 算法大致会检查下面这些内容: 属性是否是访问描述符(参见下一节)?如果是并且存在setter就调用setter。 属性的数据描述符中writable是否是false?如果是，在非严格模式下静默失败，在严格模式下抛出 TypeError 异常。 如果都不是，将该值设置为属性的值。 如果对象中不存在这个属性，[[Put]] 操作会更加复杂。会在第 5 章讨论 [[Prototype]] 时详细进行介绍。 3.3.9 Getter和Setter对象默认的 [[Put]] 和 [[Get]] 操作分别可以控制属性值的设置和获取。目前我们还无法操作[[Get]] 和 [[Put]]来改写整个对象 ,但是在ES5中可以使用 getter 和 setter 改写部分默认操作,只能应用在单个属性上，无法应用在整个对象上。 注意: 书中后面说的访问描述符就是存取描述符.关于属性描述符,存取描述符及数据描述符可以查看MDN的解释) getter:getter 是一个隐藏函数，会在获取属性值时调用。同时会覆盖该单个属性默认的 [[Get]]操作.当你设置getter时,不能同时再设置value或writable,否则就会产生一个异常.并且当你设置getter或setter时,JavaScript 会忽略它们的 value 和 writable 特性. 语法: {get prop() { ... } }或{get [expression]() { ... } }.其中prop:要设置的属性名. expression:从 ECMAScript 2015 开始可以使用计算属性名.使用方式:123456789101112131415161718192021222324var myObject = &#123; a: 1111, //在后面会发现myObject.a为2,这是因为设置了getter所以忽略了value特性. //方式一:在新对象初始化时定义一个getter get a() &#123; return 2 &#125;&#125;;Object.defineProperty( myObject, // 目标对象 "b", // 属性名 &#123; // 方式二:使用defineProperty在现有对象上定义 getter get: function()&#123; return this.a * 2 &#125;, // 确保 b 会出现在对象的属性列表中 enumerable: true &#125;);myObject.a = 3; //因为设置了getter所以忽略了writable特性.所以这里赋值没成功myObject.a; // 2myObject.b; // 4delete myObject.a;//可以使用delete操作符删除 setter:setter 是一个隐藏函数，会在获取属性值时调用。同时会覆盖该单个属性默认的 [[Put]]操作(也就是赋值操作).当你设置setter时,不能同时再设置value或writable,否则就会产生一个异常.并且当你设置getter或setter时,JavaScript 会忽略它们的 value 和 writable 特性. 语法: {set prop(val) { . . . }}或{set [expression](val) { . . . }}.其中prop:要设置的属性名. val:用于保存尝试分配给prop的值的变量的一个别名。expression:从 ECMAScript 2015 开始可以使用计算属性名.使用方式:1234567891011121314151617181920212223242526272829303132var myObject = &#123; //注意:通常来说 getter 和 setter 是成对出现的(只定义一个的话 通常会产生意料之外的行为): //方式一:在新对象初始化时定义一个setter set a(val) &#123; this._a_ = val * 2 &#125;, get a() &#123; return this._a_ &#125;&#125;;Object.defineProperty( myObject, // 目标对象 "b", // 属性名 &#123; set: function(val)&#123; this._b_ = val * 3 &#125;, // 方式二:使用defineProperty在现有对象上定义 setter get: function()&#123; return this._b_ &#125;, // 确保 b 会出现在对象的属性列表中 enumerable: true &#125;);myObject.a = 2; myObject.b = 3; console.log(myObject.a); //4console.log(myObject.b);//9console.log(myObject._a_);//4console.log(myObject._b_);//9delete myObject.a;//可以使用delete操作符删除 3.3.10 存在性属性存在性:如何判断一个对象是否存在某个属性(准确来说是检查这个属性名是否存在),这时就需要用到: in操作符in 操作符会检查属性是否在对象及其 [[Prototype]] 原型链中(参见第 5 章)。 hasOwnProperty(..)hasOwnProperty(..) 只会检查属性是否在 myObject 对象中，不会检查 [[Prototype]] 链。 注意: 1.如果有的对象可能没有连接到 Object.prototype( 通过Object. create(null) 来创建——参见第 5 章)。在这种情况下，形如myObejct.hasOwnProperty(..) 就会失败。这时可以使用一种更加强硬的方法来进行判断:Object.prototype.hasOwnProperty. call(myObject,”a”)，它借用基础的 hasOwnProperty(..) 方法并把它显式绑定(参见第2章)到 myObject 上。 2.对于数组来说,不要使用in操作符,因为它检查的是属性名,在数组中属性名就是索引,它并不是我们所关注的重点.对于数组我们更关注的是它所存的值,所以对于数组检查某个值是否存在还是采用indexOf方法. 属性可枚举性:如果一个属性存在,且它的enumerable 属性描述符为true时.则它是可枚举的.并且可以被for..in 循环.一个属性不仅仅需要存在,还需要它的enumerable 为true才是可枚举的,才能被for…in遍历到.注意: for…in不适合对数组进行遍历,对数组的遍历还是使用传统的for循环. 对属性的可枚举性判断,则需要用到以下几种方法: propertyIsEnumerable(..) 会检查给定的属性名是否直接存在于对象中(而不是在原型链上)并且满足 enumerable:true。 Object.keys(..) 会返回一个数组，包含所有可枚举属性. Object.getOwnPropertyNames(..)会返回一个数组，包含所有属性，无论它们是否可枚举。 3.4 遍历关于这节我觉得还是以理清for..in和for..of为主.后面延伸的@@iterator及Symbol.iterator的使用,没必要过于深究.注意书中123页第二行done 是一个布尔值，表示是否还有可以遍历的值。有个错误,应该改成done 是一个布尔值，表示遍历是否结束。否则你在看后面它的说明时会感觉到自相矛盾.这里我也是以for..in和for..of为主进行说明,也更贴近我们实际使用. for..in for..in 循环可以用来遍历对象的可枚举属性列表(包括 [[Prototype]] 链)。 实际上for..in遍历的并不是属性值,而是属性名(即键名 key).所以你想获取属性值还是需要手动使用obj[key]来获取. 一般在遍历对象时,推荐使用for..in.当然数组也是可以使用for..in的.在遍历数组时,推荐还是使用for..of. for..of ES6 增加了一种用来遍历数组的 for..of 循环语法(如果对象本身定义了迭代器的话也可以遍历对象) for..of与for..in最大的不同点是,它循环的是属性值,而不是属性名.不过它只循环数组里存放的值,不会涉及到对象里的key.(关于这个我后面的例子里会说具体对比明的) for..of 循环首先会向被访问对象请求一个迭代器对象，然后通过调用迭代器对象的next() 方法来遍历所有返回值。数组有内置的 @@iterator，(对象没有,所以不能使用for..of,除非我们自己定义一个)因此 for..of 可以直接应用在数组上。 例子比较1234567891011let arr = ['shotCat',111,&#123;a:'1',b:'2'&#125;]arr.say="IG niu pi!"//使用for..in循环for(let index in arr)&#123; console.log(arr[index]);//shotCat 111 &#123;a:'1',b:'2'&#125; IG niu pi!&#125;//使用for..of循环for(var value of arr)&#123; console.log(value);//shotCat 111 &#123;a:'1',b:'2'&#125;&#125;//注意 for..of并没有遍历得到` IG niu pi!`.原因我前面说过`它只循环数组里存放的值,不会涉及到对象里的key.`更不用说 [[Prototype]] 链.(for..in则会) 如何让对象也能使用for..of ?你可以选择使用书中的自己通过Object.defineProperty()定义一个Symbol.iterator属性来实现.这里我就不赘述了.也是最接近原生使用感受的.不过我这里要介绍一个稍微简单点的方法来实现.就是使用上节讲到的Object.keys()搭配使用.举个例子:12345678910111213var shotCat=&#123; name:'shotCat', age:'forever18', info:&#123; sex:'true man', city:'wuhan', girlFriend:'新垣结衣!' &#125;&#125;for(var key of Object.keys(shotCat))&#123; //使用Object.keys()方法获取对象key的数组 console.log(key+": "+shotCat[key]);&#125; 3.5 小结书中小结总结得挺全的,这里我就搬运下 JavaScript 中的对象有字面形式(比如 var a = { .. })和构造形式(比如 var a = new Array(..))。字面形式更常用，不过有时候构造形式可以提供更多选项。 对象是 6 个(或者是 7 个，取决于你的观点)基础类型之一。对象有包括 function 在内的子类型，不同子类型具有不同的行为，比如内部标签 [object Array] 表示这是对象的子类型数组。 对象就是键 / 值对的集合。可以通过 .propName 或者 [“propName”] 语法来获取属性值。访问属性时，引擎实际上会调用内部的默认 [[Get]] 操作(在设置属性值时是 [[Put]])， [[Get]] 操作会检查对象本身是否包含这个属性，如果没找到的话它还会查找 [[Prototype]] 链(参见第 5 章)。 属性的特性可以通过属性描述符来控制，比如 writable 和 configurable。此外，可以使用 Object.preventExtensions(..)、Object.seal(..) 和 Object.freeze(..) 来设置对象(及其属性)的不可变性级别。 属性不一定包含值——它们可能是具备 getter/setter 的“访问描述符”。此外，属性可以是可枚举或者不可枚举的，这决定了它们是否会出现在 for..in 循环中。 可以使用 ES6 的 for..of 语法来遍历数据结构(数组、对象，等等)中的值，for..of 会寻找内置或者自定义的 @@iterator 对象并调用它的 next() 方法来遍历数据值。 第四章 混合对象”类”注意: 正如书中提示的那样,整章一半以上几乎都是讲面向对象和类的概念.会读得人云里雾里,给人哦,也许大概就是这样子的感觉.后面我还是会对那些抽象的概念找到在JavaScript里对应的”立足点”,不至于对这些概念太”飘”. 4.1 类理论说明: 类其是描述了一种代码的组织结构形式. 在js中类常见的就是构造函数,也可以是通过ES6提供的class关键字;继承就是函数;实例化就是对象,常见的就是通过new构造函数实现的. 注意: Javascript语言不支持“类”，所谓的”类”也是模拟出的“类”。即使是ES6引入的”类”实质上也是 JavaScript 现有的基于原型的继承的语法糖。 4.1.1 “类”设计模式一句话:类其实也是一种设计模式! 类并不是必须的编程基础,而是一种可选的代码抽象. 有些语言(比如 Java)并不会给你选择的机会，类并不是可选的——万物皆是类。 其他语言(比如 C/C++ 或者 PHP)会提供过程化和面向类这两种语法，开发者可以选择其中一种风格或者混用两种风格。 4.1.2 JavaScript中的“类”JavaScript 只有一些近似类的语法元素 (比如 new 和 instanceof)，不过在后来的 ES6 中新增了一些元素，比如 class 关键字,其实质上也是 JavaScript 现有的基于原型的继承的语法糖。也不是真正的类. 4.2 类的机制这部分书中的描述,我理解起来也比较费劲,主要是它提到的栈,堆与我理解中内存里的栈,堆相冲突了.这里简单说下我的理解,如有误,感激指正. stack类其实是一种数据结构.它可以储存数据,并提供一些公用的方法(这和上面提到的类很相似).但是stack类其实只是一个抽象的表示,你想对它进行操作,就需要先对它进行实例化. 4.2.1 建造这节主要就是说明”类”和”实例”的关系.在JavaScript里”类”主要是构造函数,”实例”就是对象. 一个类就像一张蓝图。为了获得真正可以交互的对象，我们必须按照类来实例化一个东西，这个东西(对象)通常被称为实例，有需要的话，我们可以直接在实例上调用方法并访问其所有公有数据属性。 总而言之:类通过实例化得到实例对象. 4.2.2 构造函数 类实例是由一个特殊的类方法构造的，这个方法名通常和类名相同，被称为构造函数。 实例就是由构造函数实例化的: new 构造函数. 构造函数大多需要用 new 来调，这样语言引擎才知道你想要构造一个新的类实例。 构造函数会返回一个对象,这个对象就是实例.这个对象可以调用类的方法. 4.3 类的继承在面向类的语言中，你可以先定义一个类，然后定义一个继承前者的类。后者通常被称为“子类”，前者通常被称为“父类”。子类可以继承父类的行为,并且可以根据自己的需求,修改继承的行为(一般并不会修改父类的行为).注意:我们讨论的父类和子类并不是实例,在JavaScript里类一般都是构造函数。 4.3.1 多态大概你看了它的”解释”,对多态还是懵懵懂懂.这里我再解释下:什么是多态?同一个操作，作用于不同的对象，会产生不同的结果。发出一个相同的指令后，不同的对象会对这个指令有不同的反应，故称为多态。说明: 书中例子中的inherited其实就是相当于super.并且注意书中的这些例子都是伪代码! 并不是真的在JavaScript里就是这样实现的.补充:这里是关于super的mdn链接. 多态: 相对性: 其实相对性就是子类相对于父类的引用(例如使用super实现引用),并且子类对父类的引用并不会对父类的行为造成任何影响(并不会对父类自身的行为进行重新定义),例如书中例子子类对drive()的引用. 可重复定义: 子类继承父类的某个方法,并可以对这个方法进行再次定义,例如书中子类对drive()中的output进行修改.当调用方法时会自动选择合适的定义,这句话怎么理解,当子类实例化后,执行drive()方法时,它并不会直接去执行父类的drive().而是子类上的drive().简单来说就是实例来源于那个类,它就使用那个类的方法. 说明: 在 JavaScript 中“类”是属于构造函数的(类似 Foo.prototype… 这样的类型引用)。由于 JavaScript中父类和子类的关系只存在于两者构造函数对应的 .prototype 对象中，因此它们的构造函数之间并不存在直接联系，从而无法简单地实现两者的相对引用(在 ES6 的类中可以通过 super来“解决”这个问题，参见附录 A)。 多态并不表示子类和父类有关联，子类得到的只是父类的一份副本。类的继承其实就是复制。 其实这里讨论的这些概念其实在我们实际工作中,已经使用了无数次,只是现在你需要理解”原来你是叫这个名字啊!” 4.3.2 多重继承多重继承: 一个子类可以继承来自多个父类的方法.多重继承引发的问题: 多重继承可能会出现,多个父类中方法名冲突的问题,这样子类到底引用哪个方法?多重继承与JavaScript: JavaScript本身并没有提供多重继承功能.但它可以通过其他方法来达到多重继承的效果. 4.4 混入JavaScript 中只有对象，并不存在可以被实例化的“类”。一个对象并不会被复制到其他对象，它们会被关联起来(参见第 5 章)(其实就是引用,所以它的多态是”相对”的)。由于在其他语言中类表现出来的都是复制行为，因此 JavaScript 开发者也想出了一个方法来模拟类的复制行为，这个方法就是混入(就是通过混入来模拟实现类的多重继承)。 4.4.1 显式混入郑重提醒: 书中这里的类都是对象形式的.例子里的sourceObj, targetObj,这就可能造成一个”误导”,在JavaScript里是没有真正的类,所谓的类也不过是我们模拟出来的”类”,不过是一种语法糖(包括ES6里的class).在JavaScript里”所谓的类”经常是一个构造函数,你并不能这样进行遍历,只能对它的实例对象进行这种操作.不要被书中例子带进去了,不要混淆,毕竟我们最终使用的是JavaScript(而不是其他面向对象的语言.),它里面的类常常并不是一个对象! 显式混入: 书中没有给出明确的显式混入的定义,但是读完整章.基本就知道什么是显式混入了.显式混入就是通过类似mixin()方法,显式地将父对象属性逐一复制,或者有选择地复制(即例子中的存在性检查)到子对象上. 显式混入常用方法: 就是书中的例子, 首先有子对象,并对其进行特殊化(定义自己的属性或方法).然后再通过mixin()方法将父对象有选择地复制(即存在性检查,过滤子对象已有的属性,避免冲突)到子对象上. 显式混入注意点:显式混入时,切记一点你要避免父对象的属性与子对象特殊化的属性冲突.这就是为什么例子中要进行存在性检查,以及后面要说的混合复制,可能存在的重写风险. 1. 再说多态(其实说的就是js里的多态)显式多态: 将父对象里的方法通过显式绑定到子对象上.就是显式多态.例如书中的例子:Vehicle.drive.call( this )。显式多态也是为了JS来模拟实现多重继承的!说明: 在ES6之前是没有相对多态的机制。所以就使用call这种进行显式绑定实现显式动态.注意JavaScript里实现多态的方法也被称为”伪多态”.所以不要对后面突然冒出的伪多态概念而一脸懵逼(其实整本书经常做这样的事) 显式多态(伪多态)的缺陷: 因为在JavaScript 中存在屏蔽(实际是函数引用的上下文不同),所以在引用的时候就需要使用显式伪多态的方法创建一个函数关联. 这些都会增加代码的复杂度和维护难度(过多的this绑定,真的会让代码很难读)。 2. 混合复制(显式混入另一种不常用方法)前面的显式混入的方法是先有子对象并进行特殊化,然后再有选择地复制父对象属性.这个不常用的方法则是反过来的,结合书中例子,它先用一个空对象完全复制父对象的属性,然后该对象复制特殊化对象的属性,最后得到子对象.这种方法明显是比第一种麻烦的,并且在复制特殊化对象时,可能会对之前重名的属性(即复制得到的父对象属性)进行重写覆盖.所以这种方法是存在风险,且效率低下的. 显式混入的缺陷: 无法做到真正的复制: 如果复制的对象中存在对函数的引用,那么子对象得到的是和父对象一样的,对同一个函数的引用.如果某个子对象对函数进行了修改,那么父对象及其他子对象都会受到影响.很明显这是不安全的.原因是JavaScript 中的函数无法进行真正地复制，你只能复制对共享函数对象的引用. 函数名和属性名同名: 如果混入多个对象,则可能会出现这种情况.目前现在仍没有比较好的方式来处理函数和属性的同名问题(提问:这种情况下谁的优先级更高?滑稽脸)。 3. 寄生继承显式混入模式的一种变体被称为“寄生继承”，它既是显式的又是隐式的.首先会复制一份父类(对象)的定义，然后混入子类(对象)的定义(如果需要的话保留到父类的特殊引用)，然后用这个复合对象构建实例。说明: 寄生继承与混合复制是很相似的,最大的区别是寄生继承是通过实例化构造函数(JS中的”类”)来实现复制的. 4.4.2 隐式混入隐式混入: 它与显示混入最大的区别,就是它没有明显的对父类(对象)属性进行复制的过程.它是通过在构造函数调用或者方法调用中使用显式绑定例如: Something.cool.call( this)来实现混入(多重继承).其本质就是通过改变this指向来实现混入. 4.5 小结整章的重点其实就是让你理解什么叫类.除了最后一小节的混入和JavaScript有那么一点点关系.其余的小结和JavaScript都没什么关系.重要的是理解类这种思想和设计模式.重点: 1.类意味着复制! 传统的类被实例化时，它的行为会被复制到实例中。类被继承时，行为也会被复制到子类中。 多态(在继承链的不同层次名称相同但是功能不同的函数)看起来似乎是从子类引用父类，但是本质上引用的其实是复制的结果。 JavaScript 并不会(像类那样)自动创建对象的副本。(你只能自己手动复制,而且复制的还不彻底!) 混入模式(无论显式还是隐式)可以用来模拟类的复制行为，但是通常会产生丑陋并且脆弱的语法，比如显式伪多态(OtherObj.methodName.call(this, …))，这会让代码更加难 懂并且难以维护。 显式混入实际上无法完全模拟类的复制行为，因为对象(和函数!别忘了函数也是对象)只能复制引用，无法复制被引用的对象或者函数本身。忽视这一点会导致许多问题。 在 JavaScript 中模拟类是得不偿失的，虽然能解决当前的问题，但是可能会埋下更多的隐患。(但实际,我们用得却很多) 第五章 原型注意:本章的前提是你已经比较熟悉原型及原型链.不太熟或者不知道的可以,通过这篇文章熟悉下. 5.1 [[Prototype]]JavaScript 中的对象有一个特殊的 [[Prototype]] 内置属性，其实就是对于其他对象的引用(一般就是其构造函数prototype属性的引用)。几乎所有的对象在创建时 [[Prototype]] 属性都会被赋予一个非空的值。吐槽: 书中有这样一句话 “注意:很快我们就可以看到，对象的 [[Prototype]] 链接可以为空，虽然很少见。”我前前后后看了三遍都没找到它所说的对象的 [[Prototype]] 链接可以为空.的情况!应该是作者写忘记了.ok,这里我来说下对象的 [[Prototype]] 链接可以为空的情况.就是通过Object.create(null)得到的对象.它的 [[Prototype]] 是为空的.应该说它的所有都是空的.为什么?因为null是原型链的顶端.它是没有[[Prototype]]的.对应的可以对比下console.log(Object.create({}))和console.log(Object.create(null)) [[Prototype]]有什么用?我原以为作者会说可以作为存放实例对象的公共属性,然后像类一样讲得更深刻点.不过这次只是说了它表明的作用. 作用: 就是存放哪些不在对象自身的属性. 当我们访问一个对象的属性时,此时对象的内部默认操作[[Get]],首先会检查对象本身是否有这个属性，如果有的话就使用它。如果没有的话,[[Get]] 就会继续访问对象的 [[Prototype]] 链.([[Prototype]]其实就是其构造函数的prototype属性.也是一个对象.)如果找到,就返回该属性值.如果没有就继续寻找下一个[[Prototype]]链.直到找完整条[[Prototype]]链.还是没有的话,[[Get]] 就会返回undefined. 补充: 使用 for..in 遍历对象时 任何可以通过原型链访问到 (并且是 enumerable:true)的属性都会被枚举。(其实这个在第三章里我说过) 使用 in 操作符 同样会查找对象的整条原型链(无论属性是否可枚举) 5.1.1 Object.prototype所有普通的 [[Prototype]] 链最终都会指向内置的 Object.prototype。(Object.prototype的[[Prototype]] 最终会指向null.null就是最后的终点).这个 Object.prototype 对象，包含了 JavaScript 中许多通用的功能,例如:toString() , valueOf(), hasOwnProperty(..)和 isPrototypeOf(..)。 5.1.2 属性设置和屏蔽说明: 看完本节时,切记不要对myObject.foo = &quot;bar&quot;这种简单的对象属性赋值产生顾虑和疑惑.这种赋值绝对不会对原型链产生任何影响!基本也不会出现赋值不成功的情况.如果有人敢在团队项目里修改对象的属性描述符,早就被拖出去打死了!!! 这部分可以看做补充知识,知道有这些奇葩设定就行.其实这节更应该关注的是myObject.foo的返回值.注意: 书中提到的动词屏蔽其实指的就是在对象上创建同名属性(原型链上已有该属性).注意不要被绕晕了.还有++就相当于myObject.a=myObject.a+1,注意分解就行,不存在什么特别需要当心的. 5.2 “类” JavaScript里只有对象,没有类! JavaScript不需要通过类来抽象对象.而是自己直接创建对象,并定义对象的行为. 5.2.1 “类”函数吐槽:模仿类竟然被说成奇怪的无耻滥用!?不这样做,js那些高级用法怎么实现?怎么会有现在前端的百花齐放(轮子满地跑)?这也是冒得办法的办法啊!毕竟当时js只是小众,不指望它有多大能耐.毕竟只是一个人用7天”借鉴”出来的东西. “类”函数: JavaScript用来模仿类的函数就被称为类函数,其实就是我们常说的构造函数. “类”函数模拟类的关键: 所有的函数默认都会拥有一个名为 prototype 的公有并且不可枚举(参见第 3 章)的属性，它会指向另一个对象.当我们通过new 函数(构造函数)来得到实例对象时,此时new会给实例对象一个内部的 [[Prototype]]属性，实例对象内部的[[Prototype]]属性与构造函数的prototype属性都指向同一个对象.那JS的这个特性怎么模拟类呢?首先类的本质就是复制!.明白这点后,我们就需要实现伪复制.我们可以将类里的属性,放在函数的prototype属性里.这样该函数的实例对象就可以通过[Prototype]访问这些属性.我们也经常把这种行为称为原型继承(作者后面会疯狂吐槽这个称呼,我后面再解释为什么吐槽).这样就实现了伪”复制”. 可以达到和类相似的效果. 注意: 虽然说所有的函数默认都会拥有一个名为 prototype属性.但也有特殊的时候.就不是默认的情况.就是通过bind()硬绑定时.所返回的绑定函数,它是没有prototype属性的! 图解真正的类与JS的模拟类: 关于原型继承这个名字的疯狂吐槽: 作者的吐槽主要集中在”继承”两个字,原因是在面向类的语言中,”继承”意味着复制,但在JavaScript里原型继承却根本不是这个意思,它并没有复制,而是用原型链来实现.所以疯狂吐槽其误导. 什么是差异继承? 我根本没听过这个术语,初次看作者所谓的解释,这是啥?他想说啥?后来读了好多遍,终于大概理解了.如果你也看不懂作者想在表达什么,就pass这部分.没必要理解.反而会把你看得更迷惑.好了,我来解释下什么叫差异继承.差异继承就是原型继承的一个不常用的别名.我们知道对象可以通过原型链继承一部分属性,但我们仍可以给对象设置其他有差异不同的属性.这也就可以称为差异继承. 5.2.2 “构造函数”构造函数之所以是构造函数,是因为它被new调用,如果没被new调用,它就是一个普通函数.实际上,new会劫持所有普通函数并用构造对象的形式来调用它,并且无论如何都会构造返回一个对象. 5.2.3 技术关于两种“面向类”的技巧,我这就不说明了,理解了这部分第一第二章关于this的使用,就很简单了. prototype.constructor:为了正确理解constructor.我特意在标题上加上prototype.是想强调:一个对象访问constructor时,会默认访问其原型对象上的constructor属性. 注意:12345678910111213function Foo() &#123; /* .. */ &#125;Foo.prototype = &#123; /* .. */ &#125;; // 有时候我们会需要创建一个新原型对象,因此也不会有默认的constructor属性指向构造函数// 需要在 Foo.prototype 上“修复”丢失的 .constructor 属性// 关于 defineProperty(..)，参见第 3 章 Object.defineProperty( Foo.prototype, "constructor" , &#123; enumerable: false,//不可枚举 writable: true, configurable: true, value: Foo // 让 .constructor 指向 Foo&#125; );//上面这种方法是比较严谨,也比较麻烦的.并且使用Object.defineProperty()风险是很大的.//所以我们实际是这样修改的Foo.prototype.constructor=Foo; //直接将其赋值Foo 唯一要注意的是此时constructor是可枚举的.会被实例对象的for..in..遍历到. 5.3 (原型)继承原型对象到原型对象的继承:例如:Bar.prototype 到 Foo.prototype 的委托关系，正确的JavaScript中“原型风格”:1234567891011121314151617181920212223function Foo(name) &#123; this.name = name;&#125;Foo.prototype.myName = function() &#123; return this.name;&#125;;function Bar(name,label) &#123; Foo.call( this, name ); this.label = label;&#125;// 我们创建了一个新的 Bar.prototype 对象,并且它的[[Prototype]] 关联Foo.prototype Bar.prototype = Object.create( Foo.prototype );// 注意!Object.create()是返回一个新的对象,所以现在没有 Bar.prototype.constructor 了 // 如果你需要这个属性的话可能需要手动修复一下它Bar.prototype.myLabel = function() &#123; return this.label;&#125;;var a = new Bar( "a", "obj a" );a.myName(); // "a"a.myLabel(); // "obj a" 错误用法: 1, Bar.prototype = Foo.prototype; 此时并不会创建一个关联到 Bar.prototype 的新对象，它只是让 Bar.prototype 直接引用 Foo.prototype 对象。 因此当你执行类似 Bar.prototype. myLabel = … 的赋值语句时会直接修改 Foo.prototype 对象本身。 2, Bar.prototype = new Foo(); 它使用 了 Foo(..) 的“构造函数调用”，如果函数 Foo 有一些其他操作的话,尤其是与this有关的的话，就会影响到 Bar() 的“后代”，后果不堪设想。 结论: 要创建一个合适的关联对象，我们需使用 Object.create(..) 而不是使用具有副作用的 Foo(..)。这样做唯一的缺点就是需要创建一个新对象然后把旧对象抛弃掉(主要是需要手动设置constructor)，不能直接修改已有的默认对象。 检查”类”关系 instanceof 操作符: 验证左边的普通对象的整条[[prototype]]链是否有指向右边函数的prototype,例如:a instanceof Foo。 isPrototypeOf(..) 方法: 验证在对象 a 的整条 [[Prototype]] 链中是否出现过 原型对象b.例如:b.isPrototypeOf( a ); 注意: 如果使用内置的 .bind(..) 函数来生成一个硬绑定函数(参见第 2 章)的话， 该函数是没有 .prototype 属性的。如果硬绑定函数instanceof 的话,则其bind的 目标函数的prototype会成为硬绑定函数的prototype. 关于proto:我们知道函数可以直接通过prototype属性直接访问原型对象.那对象怎么访问呢?我们知道是通过[[prototype]]链.怎么访问呢?在ES5之中的标准方法:通过Object.getPrototypeOf( )方法来获取对象原型.Object.getPrototypeOf( a ) === Foo.prototype; // true,另一种方法:在 ES6 之前并不是标准,但却被绝大多数浏览器支持的一种方法,可以访问内部[[prototype]]对象.那就是__proto__.例如:a.__proto__ === Foo.prototype; // true.你甚至可以通过.__proto__.__ptoto__...来访问整个原型链. .__proto__实际上并不存在于你正在使用的对象中.并且它看起来很像一个属性，但是实际上它更像一个 getter/setter(见第三章). 5.4 对象关联[[Prototype]] 机制就是存在于对象中的一个内部链接，它会引用其他对象。 这个链接的作用是:如果在对象上没有找到需要的属性或者方法引用，引擎就会继续在 [[Prototype]] 关联的对象上进行查找。同理，如果在后者中也没有找到需要的 引用就会继续查找它的 [[Prototype]]，以此类推。这一系列对象的链接被称为原型链。 5.4.1 创建关联问:“我们已经明白了为什么 JavaScript 的 [[Prototype]] 机制和类不一样，也明白了它如何建立对象间的关联。”答: 类的机制是复制,JavaScript里原型链的机制是引用. 问:“那 [[Prototype]] 机制的意义是什么呢?为什么 JavaScript 开发者费这么大的力气(模拟类)在代码中创建这些关联呢?”答: 意义就是模拟类,JavaScript不需要复制(我觉得这不是个优点)而通过原型链实现”实例”对”类”的”继承(其实就是引用)”.这样就达到了实例对象对某些属性(即原型对象里的属性)的复用. Object.create(..)这个方法其实我们在前面已经使用过很多次.”Object.create(..) 会创建一个新对象(bar)并把它关联到我们指定的对象(foo)，这样我们就可以充分发挥 [[Prototype]] 机制的威力(委托)并且避免不必要的麻烦(比如使用 new 的构造函数调用会生成 .prototype 和 .constructor 引用)。”实际上这个方法就是创建返回一个新对象,这个新对象的原型([[Prototype]])会绑定为我们输入的参数对象foo.并且由于不是通过构造函数的形式,所以不需要为函数单独设置prototype.虽然Object.create(..)很好,但实际我们使用的更多的还是构造函数形式.注意: Object.create(..) 的第二个参数指定了需要添加到新对象中的属性名以及这些属性的属性描述符(参见第 3 章)。 Object.create(null)这个方法其实我们在前面也讲解过几次.”Object.create(null) 会创建一个拥有空(或者说null)[[Prototype]] 链接的对象，这个对象无法进行委托。由于这个对象没有原型链，所以 instanceof 操作符(之前解释过)无法进行判断，因此总是会返回 false。 这些特殊的空 [[Prototype]] 对象通常被称作“字典”，它们完全不会受到原型链的干扰，因此非常适合用来存储数据。“ “Object.create()的polyfill代码.”这部分我就不做解读了,因为现在都8102年,es6早就普及了,你几乎不可能再用到es5之前的语法了.所以这部分大家了解下即可. 5.4.2 关联关系是备用[[Prototype]] 的本质作用: 书中提到了一个观点”处理“缺失”属性或者方法时的一种备用选项。”(即备用设计模式).但随后进行了否定”但是这在 JavaScript 中并不是很常见。所以如果你使用的是这种模式，那或许应当退后一步并重新思考一下这种模式是否合适。” 作者给出的观点是:”进行委托设计模式,即例子中的内部委托(就是在对象里套了个壳再引用了一遍,为的是将委托进行隐藏).这样可以使我们的API设计得更加清晰.”文中的清晰是指,当我们需要引用原型对象的属性方法时,我们在对象内部设置对应专门的属性(例子中的doCool),进行内部委托(其实就是套个壳进行隐藏).这样我们对象的属性就是”完整”的. 在实际工作中,我们常常就是把原型对象作为存放对象的公共属性方法的地方.对于一般比较重要的操作才会在对象里进行内部委托(隐藏委托)! 5.5 小结总结得很好很全面,这里我还是直接摘抄了,不是偷懒哦! 如果要访问对象中并不存在的一个属性，[[Get]] 操作(参见第 3 章)就会查找对象内部[[Prototype]] 关联的对象。 这个关联关系实际上定义了一条“原型链”(有点像嵌套的作用域链)，在查找属性时会对它进行遍历。 所有普通对象都有内置的 Object.prototype， 指向原型链的顶端(比如说全局作用域)，如 果在原型链中找不到指定的属性就会停止。toString()、valueOf() 和其他一些通用的功能 都存在于 Object.prototype 对象上，因此语言中所有的对象都可以使用它们。 关联两个对象最常用的方法是使用 new 关键词进行函数调用，在调用的 4 个步骤(第 2 章)中会创建一个关联其他对象的新对象。 使用 new 调用函数时会把新对象的 .prototype 属性关联到“其他对象”(就是构造函数prototype所指的对象)。带 new 的函数调用 通常被称为“构造函数调用”，尽管它们实际上和传统面向类语言中的类构造函数不一样。 JavaScript 中的机制有一个核心区别，那就是不会进行复制，对象之间是通过内部的 [[Prototype]] 链关联的。 “委托”是一个更合适的术语，因为对象之间的关系不是复制而是委托。(意思就是原先继承应该改为原先委托?) 第六章 行为委托第 5 章的结论:[[Prototype]] 机制就是指对象中的一个内部链接引用另一个对象。换句话说，JavaScript 中这个机制的本质就是对象之间的关联关系。在第六章又被称为委托.PS:前面在讲原型的时候我就习惯用父对象指代原型对象(类似”父类”),用子对象指代其实例对象(类似”子类”).本章也将采用这种称呼,故下面不再说明.(其实我觉得用父对象和子对象称呼更形象) 6.1 面向委托的设计一句话:[[Prototype]]机制是面向委托的设计,是不同于面向类的设计. 下面将分别介绍类理论和委托理论. 6.1.1 类理论类理论设计方法: 首先定义一个通用父(基)类，在 父类类中定义所有任务都有(通用)的行为。接着定义子类 ，它们都继承自 父类并且会添加一些特殊的行为来处理对应的任务,并且在继承时子类可以使用方法重写(和多态)父类的行为. 类理论中许多行为可以先“抽象”到父类然后再用子类进行特殊化(重写)。ps:这部分了解即可,着重理解下面JavaScript用到的委托. 6.1.2 委托理论类理论设计方法: 首先你会定义一个”父”对象(相当于上节中的父类)，它会包含所有任务都可以使用(委托)的具体行为。接着，对于每个任务你都可以定义一个对象(“子”对象)来存储对应的数据和行为。你可以把特定的任务对象都关联到父对象上，让它们在需要的时候可以进行委托。 (其实我们一般都是用父对象来定义通用的方法,子对象进行委托.然后子对象自身个性的属性方法就写在子对象本身,并避免与父对象的属性名冲突) ps: 这节书中这段话但是我们并不需要把这些行为放在一起，**通过类的复制**，我们可以把它们分别放在各自独立 的对象中，需要时可以允许 XYZ 对象委托给 Task。有个错误.”通过类的复制”应该改为”通过”[[Prototype]]机制”.这里应该是作者的手误.在 JavaScript 中，[[Prototype]] 机制会把对象关联到其他对象。无论你多么努力地说服自 己，JavaScript 中就是没有类似“类”的抽象机制。(其实主要原因还是是JavaScript没有完整的复制机制) 委托理论的使用建议:PS:书中这里写了3条,其实只有2条,第三条不过是对第一条的说明,这里我进行了合并. 通常来说，在 [[Prototype]] 委托中最好把状态保存在委托者(子对象)而不是委托目标(父对象)上。那怎么实现呢,就是通过”this 的隐式绑定”.在委托目标(父对象)上的函数里通过this定义保存状态.当委托者(子对象)引用该函数方法时,此时的this就自动绑定到委托者上了. 在委托中我们会尽量避免在 [[Prototype]] 链的不同级别中使用相同的命名，否则就需要使用笨拙并且脆弱的语法来消除引用歧义(参见第 4 章)。 补充: 3. 在 API 接口的设计中，委托最好在内部实现，不要直接暴露出去。 这么做更多的是出于安全和接口稳定的考虑.建议子对象将所有引用父对象的方法都套个函数隐藏起来,并取一个语义化的属性名. 委托理论的使用注意: 禁止两个对象互相委托:当你将第二个对象反向委托给前一个对象时,就会报错. 调试: 这个了解下就行.知道不同浏览器和工具对委托的解析结果并不一定相同.(吐槽:看了半天到后面出现实际上，在编写本书时，这个行为被认定是 Chrome 的一个 bug， 当你读到此书时，它可能已经被修复了。我只想说WTF! 好吧,我知道chrome以前可能出现过这个”bug”了=.=) 6.1.3 比较思维模型这节主要是比较了”通过构造函数(模拟类)实现原型继承”与”通过对象关联(委托形式,Object.create( … ))实现原型继承”两种方式的区别. 结论: 通过对象关联,委托形式,更加简洁,更加清晰易懂. PS:这里我原本自己对例子画出原型示意图.但是发现是真的复杂,并且和书中简洁后的示意图是差不多的,所以这里就不展示了,免得让读者看得更头大.这里建议,读者自己在草稿纸上画出原型示意图. 6.2 类与对象其实这节讲得还是”通过构造函数(模拟类)实现原型继承”与”通过对象关联(委托形式,Object.create( … ))实现原型继承”两种方式的区别.不过这次主要是以前端实际使用场景进行讲解. 6.2.1 控件“类”这里我就不以书中的例子进行讲解了,而是直接站在更高的角度对这种”类”风格的代码进行讲解.最大特点: 1是通过构造函数进行模拟类,2是通过显式伪多态(硬绑定函数)关联两个函数.注意: 不管是类还是对象.这两种形式一般都需要定义两种数据.第一种就是实例对象要用到的”初始保存的数据”;第二种就是通用行为的定义,包括对实例对象数据的增删改查. 下面提到的显式伪多态(详见第四章),其实指的就是使用call()方法这种硬绑定. 注意ES6 class模拟类的写法我就没具体列出了.实际上class 仍然是通过 [[Prototype]] 机制实现的,不过是个表面简洁的语法糖. 虽然书中对显式伪多态称为”丑陋的”,还用了一个语气动词”呸!”.虽然这样不好,但有时用call真的很方便,所以用得也很多. 6.2.2 委托控件对象最大特点: 通过对象载体来模拟父子,并通过Object,create(…)来对两个对象进行关联.并通过委托的形式进行引用.与上节中提到的类形式还有一个区别:对象foo构建后,需要手动调用setUp方法进行初始化.故对象的构建与初始化是分开的.而构造函数形式则是在new 构造函数时, 同时进行了对象构建与初始化.(关于这点我下面还会再说明的) 关于书中这句使用类构造函数的话，你需要(并不是硬性要求，但是强烈建议)在同一个步骤中实现构造和初始化。然而，在许多情况下把这两步分开(就像对象关联代码一样)更灵活。的理解:使用类构造函数形式,当我们使用new 构造函数时,其实是在一步实现对象的构建和对象数据的初始化(通过构造函数里的call) ;使用这种委托形式,我们是分别通过Object.create( ... );构建对象和foo.setUp( ...);来初始化的.即我们是分两步实现的.这样分开的话其实是更加灵活,也更符合编程中的关注分离原则. 6.3 更简洁的设计这节也是一样通过两者的对比来突显委托设计模式的各种优点.这里我就不再对书中的例子进行解读.如果你真正理解了类和委托的话,其实是很简单的.如果觉得复杂的话,可以在纸上理一下函数和对象之间的关系,下面我就只总结下这里提到委托设计模式的优点,当然核心是更简洁. 简洁体现在: 1, 委托重点在于只需要两个实体(两个对象相互关联)，而之前的”类”模式需要三个(父”类”,子”类”,实例对象)其实可以这么理解:委托模式将”子类”和”实例对象”合为一个对象了。 2, 不需要基类(父类)来”共享”两个实体之间的行为.不需要实例化类,也不需要合成.其实这第二条就是对第一条这种结果的说明. 额外补充强调:在使用构造函数模拟类时,子类通常会对父类的行为进行重写(属性名相同);但委托模式则不会,它会重新取个属性名,再引用父对象上的行为. 6.4 更好的语法这节主要是介绍ES6提供的2个简洁写法与其中的隐患. 语法: 在 ES6 中我们可以在任意对象的字面形式中使用简洁方法声明，例如: 123 var Foo = &#123; bar() &#123; /*..*/ &#125;,//字面形式声明&#125;; 在 ES6 中我们可以用 Object. setPrototypeOf(..) 来修改对象的 [[Prototype]],具体用法可以查看MDN例如: 12345678910111213// 使用更好的对象字面形式语法和简洁方法 var AuthController = &#123; errors: [], checkAuth() &#123; // ... &#125;, server(url,data) &#123; // ... &#125; // ... &#125;;// 现在把 AuthController 关联到 LoginController Object.setPrototypeOf( AuthController, LoginController ); 弊端: 对象字面形式语法:实际上就是一个匿名函数表达式.匿名函数会导致3个缺点:1. 调试栈更难追踪;2. 自我引用(递归、事件(解除)绑定，等等)更难; 3. 代码(稍微)更难理解。(其实我觉得这3个缺点还好,影响不是那么大).但是这种简洁语法很特殊，会给对应的函数对象设置一个内部的 name 属性，这样理论上可以用在追 踪栈中。所以实际上唯一的弊端就只剩第2条了.终极建议就是:如果你需要自我引用的话，那最好使用传统的具名函数表达式来定义对应的函数，不要使用简洁方法。 Object. setPrototypeOf(..) 这个是书中没有提的,我觉得有必要进行补充下.首先,Object. setPrototypeOf(..)可能会带来性能问题,如果关心性能,则应该使用Object.create()替代.Object. setPrototypeOf(..)与Object.create()的主要区别: Object. setPrototypeOf(..)会直接修改现有对象的[[prototype]],Object.create()则是返回一个新对象.所以你需要手动设置一下丢失的的constructor属性(如果你需要的话).而使用setPrototypeOf(..)则不需要. 6.5 内省吐槽: 纵观整本书,作者关于JavaScript中模拟类和继承”的批评,说它们具有很大误导性!更是嗤之以鼻!就差爆粗口了,JavaScript就像一个异教徒,应该绑在十字架上被烧死!但是他这样的观点,都是站在其他语言的角度来看待时,产生的.我想更多的读者可能是只接触过JavaScript.那么他其实是没有这些疑惑的!!!你反而给他们讲这一大堆其他语言的”正确”含义,有时候会时得其反!让读者更加困惑,如果是理解不透彻的,反而会怀疑自己本来写的是对的代码!所以读者应该做一个可以理解作者意图,并且拥有自我见解和观点立场! 什么是内省(自省)?首先,本节需要弄懂一个问题,什么是内省,或者是自省。书中的解释是自省就是检查实例的类型。类实例的自省主要目的是通过创建方式来判断对象的结构和功能。我这里再更通俗地解释下:当我们构建得到一个实例对象时,有时候我们是不太清除它的属性和方法的.尤其是第三方库.有时候贸然使用会导致很多错误(例如调用的方法不存在,或者报错等).这个时候我们就需要通过自省.其实就是通过一系列操作,来确认实例是不是我们想要的那个,实例的方法是不是我们想要的(存在且可用). 内省的方法: 1.通过 instanceof 语法:123456789101112function Foo() &#123; // ...&#125;Foo.prototype.something = function()&#123; // ... &#125;var a1 = new Foo();// 假设我们不知道上面的过程,只知道得到实例对象a1//我们想知道a1是不是我所希望的函数Foo所构建的if (a1 instanceof Foo) &#123; a1.something();&#125; 例子中我们有一个实例对象a1,但是我们不知道a1是不是我们所希望的函数Foo所构造的,此时就可以通过instanceof进行判断. instanceof比较适合判断实例对象和构造函数之间的关系.缺陷: 但是如果我们想判断函数A是不是函数B的”子类”时,则会稍微麻烦点,我们需要像这样A.prototype instanceof B进行判断.并且也不能直接判断两个对象是否关联. 2.通过 “鸭子类型”: 为什么会叫这个名字?看了作者的解释,还是不太能接受.不太理解外国人的脑回路.你在国内和别人说”鸭子类型”,估计也是一脸懵逼.其实很简单,所谓的”鸭子类型”其实也是我们实际工作中常用的:1234//如果a1的something存在的话,则我们可以进行调用if ( a1.something) &#123; a1.something();&#125; 其实这种方法是非常常用的,排除了在不知道存在性情况下,贸然调用的风险.缺陷: 关于书中提到的缺点,四个字概括就是”以偏概全” .书中关于Promise的例子,就是以偏概全的例子.所以我们在使用时,在if判断a1.something存在时,才会在后面使用something方法.不要直接使用anotherthing,这种没确认过的方法. 3.如果使用对象关联时: 则可以比较简单的使用Object.getPrototypeOf(..)进行判断.例如Object.getPrototypeOf(a)===A其中a,A都是对象.如果为true,则说明a的原型链上含有对象A. 6.6 小结 除了类和继承设计模式,行为委托其实是更强大,更值得推广的模式(本观点仅代表作者的观点!) 行为委托认为对象之间是兄弟关系，互相委托，而不是父类和子类的关系。JavaScript 的 [[Prototype]] 机制本质上就是行为委托机制。(我觉得还是父子对象关系.我的解说里也都是父子相称) 当你只用对象来设计代码时，不仅可以让语法更加简洁，而且可以让代码结构更加清晰。 对象关联(对象之前互相关联)是一种编码风格，它倡导的是直接创建和关联对象，不把它们抽象成类。对象关联可以用基于 [[Prototype]] 的行为委托非常自然地实现]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
</search>
